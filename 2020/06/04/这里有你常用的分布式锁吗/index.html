
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>这里有你常用的分布式锁吗 | 不忘长安</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Set render engine for 360 browser -->
  <meta name="renderer" content="webkit">
  <!-- No Baidu Siteapp-->
  <meta http-equiv="Cache-Control" content="no-siteapp"/>
  <meta name="description" content="分布式锁​        单机模式下的共享资源的安全问题，我们可以使用Java的十八般武艺解决(synchronized、ReentrantLock等)，但是在多节点的环境下，Java这些同步机制显得有心无力，因为这些节点是跨JVM的，多节点中的共享数据的修改并不能对其他线程可见，实现起来也是相当困难的。换个思路，既然不能实现跨JVM多线程的可见性，我们可以努力保证当前多节点中只有一条线程访问共享">
<meta property="og:type" content="article">
<meta property="og:title" content="这里有你常用的分布式锁吗">
<meta property="og:url" content="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/index.html">
<meta property="og:site_name" content="不忘长安">
<meta property="og:description" content="分布式锁​        单机模式下的共享资源的安全问题，我们可以使用Java的十八般武艺解决(synchronized、ReentrantLock等)，但是在多节点的环境下，Java这些同步机制显得有心无力，因为这些节点是跨JVM的，多节点中的共享数据的修改并不能对其他线程可见，实现起来也是相当困难的。换个思路，既然不能实现跨JVM多线程的可见性，我们可以努力保证当前多节点中只有一条线程访问共享">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/image-20200603091629429.png">
<meta property="article:published_time" content="2020-06-04T06:47:13.000Z">
<meta property="article:modified_time" content="2020-06-04T15:18:03.893Z">
<meta property="article:author" content="supiaol">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/image-20200603091629429.png">
  
  
    <link rel="icon" href="/img/logo.jpg">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Add to homescreen for Chrome on Android -->    
    <link rel="icon" sizes="192x192" href="/img/logo.jpg">
    <!-- Add to homescreen for Safari on iOS -->
    <link rel="apple-touch-icon-precomposed" href="/img/logo.jpg">    
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="/img/logo.jpg">
    <meta name="msapplication-TileColor" content="#0e90d2">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?10f2720e6f47d1b4a5ebc811df8dc361";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不忘长安</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <!--
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
      -->
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-这里有你常用的分布式锁吗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/" class="article-date">
  <time datetime="2020-06-04T06:47:13.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      这里有你常用的分布式锁吗
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>​        单机模式下的共享资源的安全问题，我们可以使用Java的十八般武艺解决(synchronized、ReentrantLock等)，但是在多节点的环境下，Java这些同步机制显得有心无力，因为这些节点是跨JVM的，多节点中的共享数据的修改并不能对其他线程可见，实现起来也是相当困难的。换个思路，既然不能实现跨JVM多线程的可见性，我们可以努力保证当前多节点中只有一条线程访问共享资源，这样也能避免共享数据出现安全性问题，可是不管是synchronized还是ReentrantLock都不能保证在集群环境下，共享资源同一时刻只能被一条线程访问，所以需要借助分布式锁实现。</p>
<h3 id="分布式锁应具备的特性"><a href="#分布式锁应具备的特性" class="headerlink" title="分布式锁应具备的特性"></a>分布式锁应具备的特性</h3><ul>
<li><input disabled type="checkbox"> 互斥性，在任意时刻只能允许一条线程访问共享资源</li>
<li><input disabled type="checkbox"> 不能发生锁永久占用，即使有一个线程获取锁之后崩溃退出没有释放锁，也不能影响后续线程成功获取锁</li>
<li><input disabled type="checkbox"> 容错性，满足分布式理论CAP中的AP</li>
<li><input disabled type="checkbox"> 锁认主，加锁和解锁必须由同一条线程完成，并且一条线程只能解自己加的锁</li>
</ul>
<p>​       分布式锁有多种实现方式，通常使用：<strong>数据库锁</strong>、<strong>Redis分布式锁</strong>、<strong>zookepper分布式锁</strong>。</p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>​        关系型数据库通常提供了丰富的锁机制用于保障事务的隔离性，如mysql(必须是Innodb引擎)的行锁、间隙锁等。这些锁如果运用得当可以在分布式环境发挥重要作用，常用的有排他锁实现还有Version乐观锁实现。</p>
<h4 id="数据库排他锁"><a href="#数据库排他锁" class="headerlink" title="数据库排他锁"></a>数据库排他锁</h4><p>​        数据库排他锁借助于<strong>select ….from table where column=${column} for update</strong>实现，虽然是select语句，但是带上for update之后，mysql默认认为接下来马上要执行update语句，所以会在select扫描到的所有行数据加锁，并且这个select是当前读。mysql的锁是加在索引上的，mysql会在for update扫描到的行的各个索引上加锁，如果不加where条件或者column字段不是唯一索引，mysql会将行锁升级为表锁，为了提高并发性能一定要加where条件并且为唯一索引的字段。如果加上where条件并且column是唯一索引，那么在线程提交事务之前，有且只有当前线程能够访问当前行数据。</p>
<p>​        在获取到排他锁之后，我们就可以执行相应的业务代码，在业务代码执行完成之后需要手动提交事务来释放排他锁，否则别的线程仍然无法访问当前锁定的行数据。如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">domain</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isLock = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLock = lock(traceId)) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启手动提交事务 setAutoCommit(false)</span></span><br><span class="line">    String result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            result = <span class="string">"select id from table where traceId=$&#123;traceId&#125; for update"</span>;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提交事务 commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        排他锁天然满足互斥性，即使排他锁执行过程中发生错误，数据库也会主动释放锁，不影响后续线程继续获取锁，但是<strong>可能出现当前线程长时间占有排他锁，导致大量请求堵塞，最后可能发生OOM。排他锁实现的劣势很明显，因为数据库单点问题无法实现高可用，并且无法可重入。还存在的一个需要注意的问题就是Mysql的索引优化机制可能会不走指定索引。</strong></p>
<h4 id="version乐观锁"><a href="#version乐观锁" class="headerlink" title="version乐观锁"></a>version乐观锁</h4><p>​        排他锁语义上是依靠Mysql的update语句，所以仅靠update语句也可以实现分布式锁。利用update实现分布式锁的时候，我们通常会在表中给每一行数据定义一个版本号version，每次更新都需要指定version，并且返回影响行数rows，如果rows等于0，代表修改失败，然后通过查询最新的version再次执行update,直到成功,因为这种行为和CAS很像，所以称为version乐观锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String version;</span><br><span class="line">Integer rows = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">    <span class="comment">// 获取最新版本号</span></span><br><span class="line">    version = <span class="string">"select version form table where id=$&#123;id&#125;"</span>;</span><br><span class="line">    <span class="comment">// update</span></span><br><span class="line">    rows = <span class="string">"update table set column=$&#123;column&#125;,...where id =$&#123;id&#125;,version=$&#123;version&#125;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (rows != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        version乐观锁的优点在于并非性支持好(也不一定是优点)，没有真正意义上的互斥。CAS的不足，乐观锁也同样会出现，比如修改失败自旋，在高并发的场景下，自旋对性能影响比较大。</p>
<p>​        不管是基于排他锁(悲观锁)还是version乐观锁实现的分布式锁，其距离真正可靠分布式锁仍然有很多不足，而且锁实现是借助于数据库，mysql本身锁机制设计复杂，这对于我们来说并不是好的事情，在程序出现异常特别是数据库异常，增大了故障排查的难度，所以基于数据库的实现的分布式锁并不推荐使用。</p>
<h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>先领悟下Redis实现分布式锁正确的打开方式，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              String lockKey, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              String requestId, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Redis加锁就只有一行代码 jedis.set(String key, String value, String nxxx, String expx, int time);五个参数代表含义如下：</p>
<ol>
<li>key,使用key当作锁，因为key是唯一的</li>
<li>value,这个参数我们需要传入requestId,虽然key已经满足加锁条件，但是为了满足以上总结的分布式锁的第五条锁认主的特性，需要传入能够识别当前的请求的requestId，这样当前线程获取锁之后就不会被其他线程释放锁。</li>
<li>nxxx,这里传入“NX”，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>expx,这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>time,这里传入过期时间，满足第二条特性，当前线程不能永久占用锁或者崩溃退出后仍能释放锁。</li>
</ol>
<p>​       以上方法只会出现两个结果：1.当前没有锁(key不存在)，那么就进行加锁操作，必须设置过期时间；2.已存在锁，不做任何锁。总结起来以上代码几乎满足分布式锁可靠性的所有条件，NX的设置保证key已存在的情况，函数不会调用成功。value的设置保证“锁认主”；过期时间的设置保证了当前线程不会永久占用锁或者崩溃退出后无法释放锁；在单机模式形式暂且不需要考虑容错性；那么Redis是如果保证互斥性的？Redis本身就是单线程设计，天然满足互斥性。</p>
<p>下面介绍两种常见的错误实现并分析错误其错误之处：</p>
<p><strong>错误示例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        这里的setnx就是我们正确实现的第三个参数：SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；从程序正确允许的角度来看，以上实现并没有什么问题，和正常示例的set方法能够达到相同的效果，但是我们不可能只考虑正确情况下代码运行过程，对于Java程序员或者说所有从事开发的工作人员来讲，我们不仅仅需要有面向对象的思维或者面向过程的思维，更重要的是我们需要拥有面向怀疑的思维，开发过程需要我们考虑异常情况下应该怎么办。以上代码假如在执行到result==1之后，当先进程突然被kill该怎么办，还没来得及对着锁设置过期时间，那么肯定不会主动释放锁，这就不满足分布式锁的第二条特性了。</p>
<p><strong>错误示例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">    String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    String currentValueStr = jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种方式实现相对复杂，错误之处也相对隐蔽，总结起来正确流程就是：对key进行加锁，如果key已存在返回加锁成功，否则获取key的过期时间加上过期时间与当前系统时间比较，如果已经过期获取上一个锁的过期时间并重新设置过期时间，最后为了保证多线程环境只有一次能设置成功，只有设置值和当前值相同才能枷锁成功。</p>
<p>​        这里存在的问题在于<strong>1.根据当前系统时间设置过期时间，这要求分布式环境中的各个节点时钟必须相同；2.当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁</strong>。</p>
<p><strong>解锁正确实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lua脚本</span></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Redis释放锁必须要满足当先线程持有锁，否则可能出现持有锁的线程正在执行过程中被当前锁释放了锁，所以需要判断当前线程时候持有锁，如果是，那么删除当前key,这个过程必须是原子性操作，否则可能出现在判断完释放持有锁之后，锁过期了，刚好又有另外一个线程在相同的key获取到锁，接下来的del操作实际上把另外一个线程的锁释放掉了，所以整个过程必须是原子的，而Redis执行Lua脚本就是原子性的。</p>
<p><strong>错误释放锁示例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这是最常见的，也是最危险的，根本没判断当前线程释放持有锁。</p>
<p><strong>错误释放锁示例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里不是原子性的就会出现上面提到的场景。</p>
<p>​    如果线上Redis部署是集群模式，可以使用Redis官方推荐的<strong>Redisson</strong>实现分布式锁。</p>
<h3 id="Zookepper分布式锁"><a href="#Zookepper分布式锁" class="headerlink" title="Zookepper分布式锁"></a>Zookepper分布式锁</h3><p>zk实现分布式锁(排他锁)的思路：<strong>在zk上面新建一个目录locker,客户端获取锁的时候在locker目录下注册客户端对应的临时节点node_i,这些节点是有序的(这点很重要)，释放锁的时候就删除节点node_i</strong>。zk的强一致性特性，能够很好地保证在分布式高并发情况下<strong>节点的创建一定能够保证全局唯一性</strong>，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点。以下两种情况都会触发释放锁：</p>
<ul>
<li>当前获得锁的客户端发生宕机或异常，那么Zookeeper上这个临时节点就会被删除</li>
<li>正常执行完业务逻辑，客户端主动删除自己创建的临时节点</li>
</ul>
<p>实现流程：</p>
<ol>
<li>客户端在locker下成功创建顺序节点。</li>
<li>通过获取locker目录下所有子节点，遍历所有节点如果自己不是节点序号最小的那个，说明其他客户端已经获取到锁，客户端找到节点序号最小的那个node_min节点，对其注册事件监视器。</li>
<li>如果监视的节点被删除，其watcher(即上文的当前客户端)会收到相应的通知，watcher再次判断自己创建的节点序号是否最小，如果是代表获取锁成功，否则，重复以上步骤直到自己成为locker子结点中序号最小的那个。</li>
</ol>
<p>zk分布式锁实现的架构图：</p>
<img src="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/image-20200603091629429.png" alt="image-20200603091629429" style="zoom: 50%;">

<p>​        <strong>左边整个区域可代表zk集群，locker是zk下的持久化节点，node_1、node_2、node_3是右边三个客户端的顺序临时节点。</strong></p>
<p>​        Zookeeper的开源客户端<a href="http://curator.apache.org/index.html" target="_blank" rel="noopener">Curator</a>实现了分布式锁，它提供了Zookeeper各种应用场景（Recipe，如共享锁服务、master选举、分布式计数器等）的抽象封装。依靠acquire()和release()两个核心方法完成加锁和解锁，对其进行部分解读有助于我们了解zk分布式锁实现过程。</p>
<p>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorDistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="string">"localhost:2181"</span>,retryPolicy);</span><br><span class="line">        client.start();</span><br><span class="line">        CuratorFramework client2 = CuratorFrameworkFactory.newClient(<span class="string">"localhost:2182"</span>,retryPolicy);</span><br><span class="line">        client2.start();</span><br><span class="line">        <span class="comment">// 创建分布式锁, 锁空间的根节点路径为/curator/locker</span></span><br><span class="line">        InterProcessMutex mutex  = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/curator/locker"</span>);</span><br><span class="line">        <span class="keyword">final</span> InterProcessMutex mutex2  = <span class="keyword">new</span> InterProcessMutex(client2,<span class="string">"/curator/locker"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得了锁, 进行业务流程</span></span><br><span class="line">        System.out.println(<span class="string">"clent Enter mutex"</span>);</span><br><span class="line">         Thread client2Th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     mutex2.acquire();</span><br><span class="line">                     System.out.println(<span class="string">"client2 Enter mutex"</span>);</span><br><span class="line">                     mutex2.release();</span><br><span class="line">                     System.out.println(<span class="string">"client2 release lock"</span>);</span><br><span class="line">                 &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        client2Th.start();</span><br><span class="line">        <span class="comment">// 完成业务流程, 释放锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            mutex.release();</span><br><span class="line">            System.out.println(<span class="string">"client release lock"</span>);</span><br><span class="line">            client2Th.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accept()方法的关键实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">while</span> ( !isDone )&#123;</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 创建临时有序节点</span></span><br><span class="line">                ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">                <span class="comment">// 判断自己是否最小序号的节点，如果不是添加监听前面节点被删的通知</span></span><br><span class="line">                hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取锁返回节点路径</span></span><br><span class="line">        <span class="keyword">if</span> ( hasTheLock )&#123;</span><br><span class="line">            <span class="keyword">return</span> ourPath;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>internalLockLoop()方法核心实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">          .......</span><br><span class="line">            <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock&#123;</span><br><span class="line">               	<span class="comment">// 获取子节点列表按照序号从小到大排序</span></span><br><span class="line">                List&lt;String&gt; children = getSortedChildren();</span><br><span class="line">                <span class="comment">// +1 to include the slash</span></span><br><span class="line">                StringsequenceNodeName =ourPath.substring(basePath.length() + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">// 判断自己是否是当前最小序号节点</span></span><br><span class="line">                PredicateResults predicateResults = </span><br><span class="line">                    driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">                <span class="keyword">if</span> ( predicateResults.getsTheLock() )&#123;</span><br><span class="line">                    <span class="comment">// 成功获取锁</span></span><br><span class="line">                    haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">// 拿到前一个节点</span></span><br><span class="line">                    String  previousSequencePath = </span><br><span class="line">                        basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line">                 <span class="comment">// 如果没有拿到锁,调用wait，等待前一个节点删除时,通过回调notifyAll唤醒当前线程</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 设置监听器，getData会判读前一个节点是否存在，不存在就会抛出异常从而不会设置监听器</span></span><br><span class="line">                     			client.getData().usingWatcher(watcher).forPath(previousSequencePath);	                 </span><br><span class="line">                            <span class="comment">// 如果设置了millisToWait，等一段时间，到了时间删除自己跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123;</span><br><span class="line">                              millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                                startMillis = System.currentTimeMillis();</span><br><span class="line">                                <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                                    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                    h = <span class="keyword">true</span>;    </span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 等待一段时间</span></span><br><span class="line">                                wait(millisToWait);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">// 一直等待下去</span></span><br><span class="line">                                wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span> ( KeeperException.NoNodeException e ) &#123;</span><br><span class="line">                          <span class="comment">// getData发现前一个子节点被删除，抛出异常</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        zk可以实现共享式分布式锁，但是其本身可能出现“惊群”效应，在高并发的环境下，大量节点对当前持有锁节点注册监听器(共享锁模式)，当前节点释放锁之后，又会有大量节点注册下一个持有锁节点的Watcher,此时系统中将有大量“Watcher通知”。因为每个节点都需要获取locker目录下所有子节点，所以还重复执行“子节点列表获取”。不管是“Watcher注册和通知”还是“子节点列表获取“,在高并发环境下， 会对zk造成巨大的性能影响和网络冲击。</p>

      
      
  <div class="article-statement">
    <hr>  
    1.如果本文帮到了您，不妨点一下右下角的 <a>分享到</a> 按钮。<br>
    2.除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br>
    3.本博文章只代表博主当时的观点或结论，与博主公司没有任何关系。<br>
  </div>

    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/" data-id="ckb1u70ru000d2sr6cgxk4czg" class="article-share-link" data-share="baidu" data-title="这里有你常用的分布式锁吗">Share</a>
      

      
        <a href="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/04/%E4%BD%A0%E6%9D%A5%E5%95%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          你来啦
        
      </div>
    </a>
  
  
    <a href="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">我再也不怕面试被问零拷贝了</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2020/06/04/这里有你常用的分布式锁吗/" data-title="这里有你常用的分布式锁吗" data-url="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title">Follow Me</h3>
  <div class="widget">
    <ul>
      
      
    </ul>
  </div>
</div>
  
    <div class="widget-wrap">
  <h3 class="widget-title">Recommend Posts</h3>
  <div class="widget">
    <ul>
      
      
    </ul>
  </div>
</div>
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020年 06月</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Comments</h3>
    <div class="widget">
      <!-- 多说最新评论 start -->
      <div class="ds-recent-comments" data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
      <!-- 多说最新评论 end -->
      <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
      <script type="text/javascript">
        var duoshuoQuery = {short_name:"shijiajie"};
        (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
      </script>
      <!-- 多说公共JS代码 end -->
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Copyright &copy; 2012 - 2020 <a href="/" target="_blank">supiaol</a>.
      &nbsp;
      <span id="busuanzi_container_site_pv">
        总访问量 <a href="http://service.ibruce.info/" target="_blank"><span id="busuanzi_value_site_pv"></span></a> 次
      </span>
      <span id="busuanzi_container_site_uv">
        <a href="http://service.ibruce.info/" target="_blank"><span id="busuanzi_value_site_uv"></span></a> 人.
      </span>
      
    </div>
  </div>
</footer>

  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"supiaol"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>





<script src="/js/script.js"></script>


</div>
</body>
</html>
