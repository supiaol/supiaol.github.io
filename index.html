<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>不忘长安</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="不忘长安">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="不忘长安">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="不忘长安" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不忘长安</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-这里有你常用的分布式锁吗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/" class="article-date">
  <time datetime="2020-06-04T06:47:13.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/">这里有你常用的分布式锁吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>​        单机模式下的共享资源的安全性问题，我们可以使用Java的十八般武艺解决(synchronized、ReentrantLock等)，但是在多节点的环境下，Java这些同步机制显得有心无力，因为这些节点是跨JVM的，多节点的中的共享数据的修改并不能对其他线程可见，其实现也是相当困难的。换个思路，既然不能实现跨JVM多线程的可见性，我们可以努力保证当前多节点中只有一条线程访问共享资源，这样也能避免共享数据出现安全性问题，可是不管是synchronized还是ReentrantLock都不能保证在集群环境下，共享资源同一时刻只能被一条线程访问，所以需要借助分布式锁实现。</p>
<h3 id="分布式锁应具备的特性"><a href="#分布式锁应具备的特性" class="headerlink" title="分布式锁应具备的特性"></a>分布式锁应具备的特性</h3><ul>
<li><input disabled type="checkbox"> 互斥性，在任意时刻只能允许一条线程访问共享资源</li>
<li><input disabled type="checkbox"> 不能发生锁永久占用，即使有一个线程获取锁之后崩溃退出没有释放锁，也不能影响后续线程成功获取锁</li>
<li><input disabled type="checkbox"> 容错性，满足分布式理论CAP中的AP</li>
<li><input disabled type="checkbox"> 锁认主，加锁和解锁必须由同一条线程完成，并且一条线程只能解自己加的锁</li>
</ul>
<p>​       分布式锁有多种实现方式，通常使用：<strong>数据库锁</strong>、<strong>Redis分布式锁</strong>、<strong>zookepper分布式锁</strong>。</p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>​        关系型数据库通常提供了丰富的锁机制用于保障事务的隔离性，如mysql(必须是Innodb引擎)的行锁、间隙锁等。这些锁如果运用得当可以在分布式环境发挥重要作用，常用的有排他锁实现还有Version乐观锁实现。</p>
<h4 id="数据库排他锁"><a href="#数据库排他锁" class="headerlink" title="数据库排他锁"></a>数据库排他锁</h4><p>​        数据库排他锁借助于<strong>select ….from table where column=${column} for update</strong>实现，虽然是select语句，但是带上for update之后，mysql默认认为接下来马上要执行update语句，所以会在select扫描到的所有行数据加锁，并且这个select是当前读。mysql的锁是加在索引上的，mysql会在for update扫描到的行的各个索引上加锁，如果不加where条件或者column字段不是唯一索引，mysql会将行锁升级为表锁，为了提高并发性能一定要加where条件并且为唯一索引的字段。如果加上where条件并且column是唯一索引，那么在线程提交事务之前，有且只有当前线程能够访问当前行数据。</p>
<p>​        在获取到排他锁之后，我们就可以执行相应的业务代码，在业务代码执行完成之后需要手动提交事务来释放排他锁，否则别的线程仍然无法访问当前锁定的行数据。如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">domain</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isLock = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLock = lock(traceId)) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启手动提交事务 setAutoCommit(false)</span></span><br><span class="line">    String result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            result = <span class="string">"select id from table where traceId=$&#123;traceId&#125; for update"</span>;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提交事务 commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        排他锁天然满足互斥性，即使排他锁执行过程中发生错误，数据库也会主动释放锁，不影响后续线程继续获取锁，但是<strong>可能出现当前线程长时间占有排他锁，导致大量请求堵塞，最后可能发生OOM。排他锁实现的劣势很明显，因为数据库单点问题无法实现高可用，并且无法可重入。还存在的一个需要注意的问题就是Mysql的索引优化机制可能会不走指定索引。</strong></p>
<h4 id="version乐观锁"><a href="#version乐观锁" class="headerlink" title="version乐观锁"></a>version乐观锁</h4><p>​        排他锁语义上是依靠Mysql的update语句，所以仅靠update语句也可以实现分布式锁。利用update实现分布式锁的时候，我们通常会在表中给每一行数据定义一个版本号version，每次更新都需要指定version，并且返回影响行数rows，如果rows等于0，代表修改失败，然后通过查询最新的version再次执行update,直到成功,因为这种行为和CAS很像，所以称为version乐观锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String version;</span><br><span class="line">Integer rows = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">    <span class="comment">// 获取最新版本号</span></span><br><span class="line">    version = <span class="string">"select version form table where id=$&#123;id&#125;"</span>;</span><br><span class="line">    <span class="comment">// update</span></span><br><span class="line">    rows = <span class="string">"update table set column=$&#123;column&#125;,...where id =$&#123;id&#125;,version=$&#123;version&#125;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (rows != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        version乐观锁的优点在于并非性支持好(也不一定是优点)，没有真正意义上的互斥。CAS的不足，乐观锁也同样会出现，比如修改失败自旋，在高并发的场景下，自旋对性能影响比较大。</p>
<p>​        不管是基于排他锁(悲观锁)还是version乐观锁实现的分布式锁，其距离真正可靠分布式锁仍然有很多不足，而且锁实现是借助于数据库，mysql本身锁机制设计复杂，这对于我们来说并不是好的事情，在程序出现异常特别是数据库异常，增大了故障排查的难度，所以基于数据库的实现的分布式锁并不推荐使用。</p>
<h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>先领悟下Redis实现分布式锁正确的打开方式，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              String lockKey, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              String requestId, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Redis加锁就只有一行代码 jedis.set(String key, String value, String nxxx, String expx, int time);五个参数代表含义如下：</p>
<ol>
<li>key,使用key当作锁，因为key是唯一的</li>
<li>value,这个参数我们需要传入requestId,虽然key已经满足加锁条件，但是为了满足以上总结的分布式锁的第五条锁认主的特性，需要传入能够识别当前的请求的requestId，这样当前线程获取锁之后就不会被其他线程释放锁。</li>
<li>nxxx,这里传入“NX”，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>expx,这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>time,这里传入过期时间，满足第二条特性，当前线程不能永久占用锁或者崩溃退出后仍能释放锁。</li>
</ol>
<p>​       以上方法只会出现两个结果：1.当前没有锁(key不存在)，那么就进行加锁操作，必须设置过期时间；2.已存在锁，不做任何锁。总结起来以上代码几乎满足分布式锁可靠性的所有条件，NX的设置保证key已存在的情况，函数不会调用成功。value的设置保证“锁认主”；过期时间的设置保证了当前线程不会永久占用锁或者崩溃退出后无法释放锁；在单机模式形式暂且不需要考虑容错性；那么Redis是如果保证互斥性的？Redis本身就是单线程设计，天然满足互斥性。</p>
<p>下面介绍两种常见的错误实现并分析错误其错误之处：</p>
<p><strong>错误示例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        这里的setnx就是我们正确实现的第三个参数：SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；从程序正确允许的角度来看，以上实现并没有什么问题，和正常示例的set方法能够达到相同的效果，但是我们不可能只考虑正确情况下代码运行过程，对于Java程序员或者说所有从事开发的工作人员来讲，我们不仅仅需要有面向对象的思维或者面向过程的思维，更重要的是我们需要拥有面向怀疑的思维，开发过程需要我们考虑异常情况下应该怎么办。以上代码假如在执行到result==1之后，当先进程突然被kill该怎么办，还没来得及对着锁设置过期时间，那么肯定不会主动释放锁，这就不满足分布式锁的第二条特性了。</p>
<p><strong>错误示例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">    String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    String currentValueStr = jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种方式实现相对复杂，错误之处也相对隐蔽，总结起来正确流程就是：对key进行加锁，如果key已存在返回加锁成功，否则获取key的过期时间加上过期时间与当前系统时间比较，如果已经过期获取上一个锁的过期时间并重新设置过期时间，最后为了保证多线程环境只有一次能设置成功，只有设置值和当前值相同才能枷锁成功。</p>
<p>​        这里存在的问题在于<strong>1.根据当前系统时间设置过期时间，这要求分布式环境中的各个节点时钟必须相同；2.当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁</strong>。</p>
<p><strong>解锁正确实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lua脚本</span></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Redis释放锁必须要满足当先线程持有锁，否则可能出现持有锁的线程正在执行过程中被当前锁释放了锁，所以需要判断当前线程时候持有锁，如果是，那么删除当前key,这个过程必须是原子性操作，否则可能出现在判断完释放持有锁之后，锁过期了，刚好又有另外一个线程在相同的key获取到锁，接下来的del操作实际上把另外一个线程的锁释放掉了，所以整个过程必须是原子的，而Redis执行Lua脚本就是原子性的。</p>
<p><strong>错误释放锁示例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这是最常见的，也是最危险的，根本没判断当前线程释放持有锁。</p>
<p><strong>错误释放锁示例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里不是原子性的就会出现上面提到的场景。</p>
<p>​    如果线上Redis部署是集群模式，可以使用Redis官方推荐的<strong>Redisson</strong>实现分布式锁。</p>
<h3 id="Zookepper分布式锁"><a href="#Zookepper分布式锁" class="headerlink" title="Zookepper分布式锁"></a>Zookepper分布式锁</h3><p>zk实现分布式锁(排他锁)的思路：<strong>在zk上面新建一个目录locker,客户端获取锁的时候在locker目录下注册客户端对应的临时节点node_i,这些节点是有序的(这点很重要)，释放锁的时候就删除节点node_i</strong>。zk的强一致性特性，能够很好地保证在分布式高并发情况下<strong>节点的创建一定能够保证全局唯一性</strong>，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点。以下两种情况都会触发释放锁：</p>
<ul>
<li>当前获得锁的客户端发生宕机或异常，那么Zookeeper上这个临时节点就会被删除</li>
<li>正常执行完业务逻辑，客户端主动删除自己创建的临时节点</li>
</ul>
<p>实现流程：</p>
<ol>
<li>客户端在locker下成功创建顺序节点。</li>
<li>通过获取locker目录下所有子节点，遍历所有节点如果自己不是节点序号最小的那个，说明其他客户端已经获取到锁，客户端找到节点序号最小的那个node_min节点，对其注册事件监视器。</li>
<li>如果监视的节点被删除，其watcher(即上文的当前客户端)会收到相应的通知，watcher再次判断自己创建的节点序号是否最小，如果是代表获取锁成功，否则，重复以上步骤直到自己成为locker子结点中序号最小的那个。</li>
</ol>
<p>zk分布式锁实现的架构图：</p>
<img src="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/image-20200603091629429.png" alt="image-20200603091629429" style="zoom: 50%;">

<p>​        <strong>左边整个区域可代表zk集群，locker是zk下的持久化节点，node_1、node_2、node_3是右边三个客户端的顺序临时节点。</strong></p>
<p>​        Zookeeper的开源客户端<a href="http://curator.apache.org/index.html" target="_blank" rel="noopener">Curator</a>实现了分布式锁，它提供了Zookeeper各种应用场景（Recipe，如共享锁服务、master选举、分布式计数器等）的抽象封装。依靠acquire()和release()两个核心方法完成加锁和解锁，对其进行部分解读有助于我们了解zk分布式锁实现过程。</p>
<p>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorDistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="string">"localhost:2181"</span>,retryPolicy);</span><br><span class="line">        client.start();</span><br><span class="line">        CuratorFramework client2 = CuratorFrameworkFactory.newClient(<span class="string">"localhost:2182"</span>,retryPolicy);</span><br><span class="line">        client2.start();</span><br><span class="line">        <span class="comment">// 创建分布式锁, 锁空间的根节点路径为/curator/locker</span></span><br><span class="line">        InterProcessMutex mutex  = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/curator/locker"</span>);</span><br><span class="line">        <span class="keyword">final</span> InterProcessMutex mutex2  = <span class="keyword">new</span> InterProcessMutex(client2,<span class="string">"/curator/locker"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得了锁, 进行业务流程</span></span><br><span class="line">        System.out.println(<span class="string">"clent Enter mutex"</span>);</span><br><span class="line">         Thread client2Th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     mutex2.acquire();</span><br><span class="line">                     System.out.println(<span class="string">"client2 Enter mutex"</span>);</span><br><span class="line">                     mutex2.release();</span><br><span class="line">                     System.out.println(<span class="string">"client2 release lock"</span>);</span><br><span class="line">                 &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        client2Th.start();</span><br><span class="line">        <span class="comment">// 完成业务流程, 释放锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            mutex.release();</span><br><span class="line">            System.out.println(<span class="string">"client release lock"</span>);</span><br><span class="line">            client2Th.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accept()方法的关键实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">while</span> ( !isDone )&#123;</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 创建临时有序节点</span></span><br><span class="line">                ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">                <span class="comment">// 判断自己是否最小序号的节点，如果不是添加监听前面节点被删的通知</span></span><br><span class="line">                hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取锁返回节点路径</span></span><br><span class="line">        <span class="keyword">if</span> ( hasTheLock )&#123;</span><br><span class="line">            <span class="keyword">return</span> ourPath;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>internalLockLoop()方法核心实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">          .......</span><br><span class="line">            <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock&#123;</span><br><span class="line">               	<span class="comment">// 获取子节点列表按照序号从小到大排序</span></span><br><span class="line">                List&lt;String&gt; children = getSortedChildren();</span><br><span class="line">                <span class="comment">// +1 to include the slash</span></span><br><span class="line">                StringsequenceNodeName =ourPath.substring(basePath.length() + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">// 判断自己是否是当前最小序号节点</span></span><br><span class="line">                PredicateResults predicateResults = </span><br><span class="line">                    driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">                <span class="keyword">if</span> ( predicateResults.getsTheLock() )&#123;</span><br><span class="line">                    <span class="comment">// 成功获取锁</span></span><br><span class="line">                    haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">// 拿到前一个节点</span></span><br><span class="line">                    String  previousSequencePath = </span><br><span class="line">                        basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line">                 <span class="comment">// 如果没有拿到锁,调用wait，等待前一个节点删除时,通过回调notifyAll唤醒当前线程</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 设置监听器，getData会判读前一个节点是否存在，不存在就会抛出异常从而不会设置监听器</span></span><br><span class="line">                     			client.getData().usingWatcher(watcher).forPath(previousSequencePath);	                 </span><br><span class="line">                            <span class="comment">// 如果设置了millisToWait，等一段时间，到了时间删除自己跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123;</span><br><span class="line">                              millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                                startMillis = System.currentTimeMillis();</span><br><span class="line">                                <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                                    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                    h = <span class="keyword">true</span>;    </span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 等待一段时间</span></span><br><span class="line">                                wait(millisToWait);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">// 一直等待下去</span></span><br><span class="line">                                wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span> ( KeeperException.NoNodeException e ) &#123;</span><br><span class="line">                          <span class="comment">// getData发现前一个子节点被删除，抛出异常</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        zk可以实现共享式分布式锁，但是其本身可能出现“惊群”效应，在高并发的环境下，大量节点对当前持有锁节点注册监听器(共享锁模式)，当前节点释放锁之后，又会有大量节点注册下一个持有锁节点的Watcher,此时系统中将有大量“Watcher通知”。因为每个节点都需要获取locker目录下所有子节点，所以还重复执行“子节点列表获取”。不管是“Watcher注册和通知”还是“子节点列表获取“,在高并发环境下， 会对zk造成巨大的性能影响和网络冲击。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/" data-id="ckb0c8om10000jcr68k9fguig" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-我再也不怕面试被问零拷贝了" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/" class="article-date">
  <time datetime="2020-06-04T05:51:41.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/">我再也不怕面试被问零拷贝了</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下面这段Java代码关于I/O的简单实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从本地读取jpg文件</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"supiaol.jpg"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个buffer</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">fileInputStream.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8081</span>).accept();</span><br><span class="line">socket.getOutputStream().write(buffer);</span><br></pre></td></tr></table></figure>

<p>​        上面代码到底是怎么将本地文件输出呢？底层实现经过了几次上下文切换，几次拷贝？整个过程是怎样的？详见下图:</p>
<p><img src="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/4236553-174b8d9cc6119e67.webp" alt></p>
<p>​        首先需要了解DMA(Direct Memory Access):<strong>直接内存存取</strong>，现代计算机重要特性，允许不同速度的硬件设备交互而不需要依赖CPU的中断，在I/O实现中即不需要将磁盘数据读取到主存中，DMA引擎直接将数据传输到内核缓存区，从而解放了CPU。</p>
<ol>
<li>我们本地的文件存储在磁盘上的，当需要用到的时候(调用read)用户态切换到内核态(第一次上下文切换)，同时开始第一次拷贝:DMA引擎将supiaol.jpg传输到内核缓冲区，等待下一步处理。</li>
<li>第二次拷贝：CPU将内核缓冲区的数据拷贝到用户程序的缓冲区中(第二次上下文切换)</li>
<li>第三次拷贝：调用write()方法将用户缓冲区数据拷贝到Socket缓冲区(内核中,第三次上下文切换)</li>
<li>第四次拷贝：write()执行返回，再次从内核态切换到用户态。调用write()方法时，使用DMA独立且异步的将Socket缓冲区数据拷贝到协议引擎(同在内核中不需要上下文切换)，形容成独立且异步是因为write返回并不代表数据已经传输完成，甚至不能保证已经开始传输，这能代表以太网驱动程序队列中已经获取到其描述符，并接受传输请求，所以这里说是独立且异步进行的。</li>
</ol>
<p>​      以上过程共经历了四次上下文切换，四次数据拷贝，对于CPU来说，这样的过程还有很大优化空间，方法上可以从减少上下文切换和内存拷贝两方面入手，实现上可以通过某些硬件完全绕开主内存，于是出现了<strong>mmap</strong>和<strong>sendfile</strong>两种零拷贝方案。</p>
<h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h3><p>​        mmap(一种内存映射文件的方法)：将一个文件或者对象内存。文件被映射到多个页上，如果文件的大小不等于所有页之和，那最后一个不被使用的页将被清零。mmap在用户空间映射到调用系统中作用很大。</p>
<p>​        在mmap的支持下，将read()调用改为mmap调用将发生以下变化：</p>
<p><img src="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/4236553-c5ea00b78e1b93fd.webp" alt></p>
<p>​        图中可以看到，<strong>在将数据读取到内核缓冲区后并没有再将数据拷贝到用户缓冲区，而是通过mmap将内核缓冲区地址映射到Socket缓冲区中</strong>，这样不光减少一次内存拷贝，还避免了一次上下文切换，整个过程只剩下三次上下文切换和三次内存拷贝。但是mmap并不是完美的，文件在内存映射的过程中如果另外一个线程将同一个文件截断，再调用write()方法时总线将发生SIGBUS错误中断写入过程，因为执行了错误的文件访问，该信号默认行为是杀死进程并转储核心，在网络服务器中这并不是理想操作。针对SIGBUS处理有两种解决方法：</p>
<ol>
<li>针对SIGBUS信号安装信号处理程序,在处理程序中记录已写入字节数并安全返回，这种方式本质上没有避免SIGBUS错误信号的出现。</li>
<li>内核进行文件租赁(Windows中的“机会锁定”)，通过在文件描述符上使用租赁，这样可以和内核一起使用特定文件，当另外一个线程访问文件时，内核会发送一个实时信号告诉当前线程内核可能正在破坏映射文件,在调用write()方法访问无效地址之前中断映射，返回已写入字节数。</li>
</ol>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>​        内核在2.1版本引入sendfile系统调用对I/O继续优化。使用sendfile替换read系统调用后整个过程如下：</p>
<p><img src="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/4236553-695904d24edc2fd5.webp" alt></p>
<p>​        <strong>可以明显看出sendfile减少了一次上下文切换，这是因为内核缓冲区与Socket缓冲区之间关联，然后发生第二次复制DMA引擎将数据从内核Socket缓冲区传递到协议引擎</strong>。sendfile是否面临和mmap同样的问题，另外一个进程阶段了调用传输的文件？这里sendfile已经做了相应的处理，如果我们不注册任何信号处理器，sendfile调用将简单返回其在中断之前传输的字节数。</p>
<p>​        经过sendfile的再次优化，目前只剩下内核缓冲区中一份副本(两次拷贝)，那么还有没有办法连这一份副本也避免掉呢？在绝对硬件的支持下是可以做到的——如果网络接口能够支持收集操作。这意味需要传输的数据不需要在连续内存中，可以分散在各个存储位置。在内核2.4中对套接字缓冲区描述符进行了修改用于适应这些要求，这样不仅减少了多次上下文切换，还消除了处理器的重复数据。整个过程如下：</p>
<p><img src="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/4236553-00c3e47936ecea25.webp" alt></p>
<ol>
<li>sendfile系统调用使DMA引擎将文件内容复制到内核缓冲区中。</li>
<li>避免了数据复制到套接字缓冲区中，而是将相关数据的行踪和长度信息的描述符附加到Socket缓冲区，DMA引擎将数据直接从内核缓冲区传递到协议引擎，实现副本的消除。</li>
</ol>
<p>​     最终执行经过定格在三次上下文切换，两次拷贝，那为什么说是零拷贝呢？维基上描述零拷贝：<strong>CPU不执行拷贝数据</strong>从一个存储区域到另一个存储区域的任务。视线对焦到“CPU不执行拷贝数据”，所以无论是mmap+write还是sendfile从操作系统的角度来看都是零拷贝。</p>
<p>零拷贝优点：</p>
<p>1.减少数据拷贝</p>
<p>2.减少上下文切换</p>
<p>3.更少的CPU数据缓存污染</p>
<p>4.释放CPU，无须借助CPU校验和计算。</p>
<h3 id="Java-NIO-实现零拷贝"><a href="#Java-NIO-实现零拷贝" class="headerlink" title="Java NIO 实现零拷贝"></a>Java NIO 实现零拷贝</h3><p>​        Java NIO引入了用于通道的缓冲区ByteBuffer,对比于直接操作Byte[],ByteBuffer有两种模式:<strong>直接/间接</strong>。间接模式的代表就是HeapByteBuffer,即操作堆内存的字节数组。但是在处理超大文件时，更快的是采用直接模式，代表就是MappedByteBuffer——文件映射，NIO引入的文件内存映射方案，读写性能极高。</p>
<p>​        不管是mmap还是sendfile，其中都用到了内存映射，到底什么是内存映射？操作系统管理内存分为两部分，物理内存和虚拟内存。后者就是我们所说的内存映射，虚拟内存一般使用的是页面映像文件，即硬盘中某个或者某些特殊的文件。MappedByteBuffer 将文件映射到内存(虚拟内存)，通常可以映射整个文件，如果文件过大可以分段进行映射。</p>
<p>​        FileChannel提供了map方法把文件映射成内存映像文件：<strong>MappedByteBuffer map(int mode,long position,long size)</strong>（将文件指定position开始位置的size大小的区域映射为mode模式的映像文件）,model有以下几种可选：</p>
<ul>
<li>READ_ONLY(只读)：试图修改得到的缓冲区将抛出ReadOnlyBufferException。</li>
<li>READ_WRITE(读/写)：对得到的映像文件的缓冲区的更改不会传播到文件，该更改对映射到同一文件的其他线程不一定是可见的。</li>
<li>PRIVATE(专用)：对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他线程也是不可见的；相反，会创建缓冲区已修改部分的专用副本。</li>
</ul>
<p>MappedByteBuffer在ByteBuffer的基础之上扩充了三个方法：</p>
<ul>
<li>force()：缓冲区是READ_WRITE模式下，此方法对缓冲区的修改强行写入文件；</li>
<li>load()：将缓冲区的内容载入内存，并返回该缓冲区的引用；</li>
<li>isLoaded()：如果缓冲区的内容在物理内存中返回true，否则返回false;</li>
</ul>
<h4 id="ByteBuffer和MappedByteBuffer对比"><a href="#ByteBuffer和MappedByteBuffer对比" class="headerlink" title="ByteBuffer和MappedByteBuffer对比"></a>ByteBuffer和MappedByteBuffer对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bytebuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testByteBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"supiaol.jpg"</span>, <span class="string">"rw"</span>);</span><br><span class="line">            channel = raf.getChannel();</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate((<span class="keyword">int</span>) raf.length());</span><br><span class="line">            buff.clear();</span><br><span class="line">            channel.read(buff);</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"ByteBuffer read time: "</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (raf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    raf.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MappedByteBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMappedByteBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"supiaol.jpg"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        channel = raf.getChannel();</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// map</span></span><br><span class="line">        MappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, raf.length());</span><br><span class="line">        buff.clear();</span><br><span class="line">        channel.read(buff);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"MappedByteBuffer read time: "</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (raf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                raf.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testByteBuffer();</span><br><span class="line">    System.out.println(<span class="string">"======================"</span>);</span><br><span class="line">    testMappedByteBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">ByteBuffer read time: <span class="number">2</span>ms</span><br><span class="line">======================</span><br><span class="line">MappedByteBuffer read time: <span class="number">1</span>ms</span><br></pre></td></tr></table></figure>

<p>​        可以看出读取相同大小的文件，MappedByteBuffer速度更快，在读取超大文件的时候，两者时间上的差异会更大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/" data-id="ckb0d4uwp0000f8r63y3t3zod" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis持久化也就这么多需要掌握的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/" class="article-date">
  <time datetime="2020-06-04T05:50:27.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/">Redis持久化也就这么多需要掌握的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis是内存数据库，数据的读取与操作都是在内存中进行的，这种方式在提供高性能服务的同时也面临巨大的风险，如服务器宕机、异常重启等诸如不确定因素，重启之后内存中的数据都会被清空，这显然是灾难级的事故。针对这种非常可能出现的问题，Redis必须考虑支持数据持久化，为此，Redis提供了两种持久化方案：<strong>RDB持久化</strong>和<strong>AOF持久化</strong>。持久化的出现也是Redis实现高可用的基础。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>​        RDB可以理解为某一时刻数据库的快照样本。RDB持久化会将数据库某一时刻的状态全部保存在一个RDB文件中，这个文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。因为RDB文件是保存在硬盘里的，所以即使Redis服务器进程退出，也能通过在重启的时候载入RDB文件来还原。RDB持久化有两种执行方式：<strong>手动执行和根据配置定期执行</strong>。Redis实现RDB持久化的命令有<strong>SAVE</strong>和<strong>BGSAVE</strong>两种。</p>
<ul>
<li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建成功为止，在<strong>服务器进程阻塞期间不能接受客户端任何命令请求</strong>。</li>
<li>BGSAVE(background save,即使后台保存)命令会派生出一个<strong>子进程</strong>，由子进程负责生产RDB文件，父线程继续接受客户端命令请求。注意这里是子进程。</li>
</ul>
<h4 id="RDB持久化工作原理"><a href="#RDB持久化工作原理" class="headerlink" title="RDB持久化工作原理"></a>RDB持久化工作原理</h4><p>生成RDB文件的实际工作是由<strong>rdb.c/rdbSave</strong>函数完成，SAVE和BGSAVE命令的实现以不同的方式调用<strong>rdb.c/rdbSave</strong>函数生成RDB文件。通过以下伪代码可以看出这两个命令的差别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">SAVE</span><span class="params">()</span>:</span></span><br><span class="line">	#创建RDB文件</span><br><span class="line">	rdbSave()</span><br><span class="line">        </span><br><span class="line"><span class="function">def <span class="title">BGSAVE</span><span class="params">()</span>:</span></span><br><span class="line">	#创建子进程</span><br><span class="line">	pid=fork()</span><br><span class="line">        <span class="keyword">if</span> pid==<span class="number">0</span></span><br><span class="line">            #子进程创建RDB文件</span><br><span class="line">            rdbSave()</span><br><span class="line">            #完成后向父线程发送信号</span><br><span class="line">            signal_parent()</span><br><span class="line">        elif pid&gt;<span class="number">0</span>:</span><br><span class="line">			#父线程继续处理客户端命令请求,并轮询等待子进程信号</span><br><span class="line">			handle_request_and_wait_signal()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">					#处理错误</span><br><span class="line">					handle_fork_error()</span><br></pre></td></tr></table></figure>

<p>​        <strong>和使用SAVE或者BGSAVE生成RDB文件不同，Redis并没有专门的命令用于载入RDB文件，只要Redis在启动时检测到RDB文件存在，就会自动载入</strong>。并且在载入期间服务器处于阻塞状态直到载入完成</p>
<p>​        如果RDB和AOF持久化同时打开，Redis启动优先使用AOF还原数据库状态，原因是因为AOF因为其特性恢复的数据库状态可能比RDB文件更新。只有AOF持久化功能关闭状态，Redis才使用RDB文件还原数据库。</p>
<p>​        Redis在某段时间内的只能处理一种持久化方案，SAVE、BGSAVE、BGREWRITEAOF(也是持久化命令，下面会讲)执行条件如下：</p>
<ul>
<li>BGSAVE命令执行期间，发送SAVE命令被拒绝，再次执行BGSAVE同样会被拒绝</li>
<li>BGSAVE命令执行期间，发送BGREWRITEAOF命令被延迟执行，直到BGSAVE命令执行完毕再执行BGREWRITEAOF</li>
<li>BGREWRITEAOF执行期间，发送BGSAVE命令被拒绝</li>
</ul>
<p>​       BGSAVE和SAVE不能同时执行是为了避免主从进程同时用于持久化，此时无法接受服务器请求命令，否则BGSAVE失去原有的优势。BGSAVE和BGREWRITEAOF是由两个不同的子进程执行，这两个命令在操作方面没有冲突，不能同时执行是处于性能考虑。</p>
<h4 id="BGSAVE自动执行"><a href="#BGSAVE自动执行" class="headerlink" title="BGSAVE自动执行"></a>BGSAVE自动执行</h4><p>​        Redis支持手动执行命令生成RDB文件和根据配置自动生成两种选择。Redis服务器启动时，用户可以通过指定配置文件或者传入配置参数设置save选项。根据配置生成RDB文件比较灵活，用户可以配置多项条件，只要其中一条满足Redis就会自动执行BGSAVE命令，其默认配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1   #900秒之内对数据库至少修改了一次</span><br><span class="line">save 300 10  #300秒之内对数据库至少修改了10次</span><br><span class="line">save 60  10000  #60秒内对数据库至少进行了10000次修改</span><br></pre></td></tr></table></figure>

<p>​        用户的配置会被设置为服务器状态redisServer结构的saveparams属性，saveparams属性是一个数组，数组的每个元素都是一个saveparam，每个saveparam都保存了上面的一条配置，其结构有两个属性seconds(秒数)和changes(修改数)。其结构如下：</p>
<img src="/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/image-20200603144220279.png" style="zoom:67%;">

<p>​        除此之外服务器状态redisServer还维护一个dirty计时器和lastsave上次保存属性。dirty计时器用于记录距离上一次成功执行SAVE命令或者BGSAVE命令之后服务器对数据库状态进行了多少次修改，lastsave是一个UNIX时间戳记录服务器上一次成功执行SAVE或者BGSAVE命令的时间。服务器每成功执行一个数据库修改命令，程序会对dirty计数器加1。</p>
<p>​        Redis的服务器周期性操作函数serverCron(Redis最核心函数，用于运行和维护Redis所有状态)每隔100毫秒执行一次，它其中的一项工作内容就是检查save选项所设置的保存条件是否已经满足，如果满足就会执行BGSAVE命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">serverCron</span><span class="params">()</span>:</span></span><br><span class="line">	#...</span><br><span class="line">	#遍历所有保存条件</span><br><span class="line">	<span class="keyword">for</span> saveparams in server.saveparam:</span><br><span class="line">		#计算距离上次执行保存操作有多少秒</span><br><span class="line">		save_intervel=unixtime_now()-server.lastsave</span><br><span class="line">            #如果数据库状态的修改次数超过配置次数，并且距离上次保存的时间超过条件所设置的时间</span><br><span class="line">            #那么执行保存操作</span><br><span class="line">            <span class="keyword">if</span> server.dirty &gt;= saveparam.changes <span class="keyword">and</span> save_interval&gt;savaparam.seconds:</span><br><span class="line">			BGSAVE()</span><br><span class="line">    </span><br><span class="line">    #...</span><br></pre></td></tr></table></figure>

<h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a><strong>RDB文件结构</strong></h4><p>​        一个完整RDB文件所包含的各个部分如下：</p>
<img src="/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/image-20200603151239186.png">

<pre><code>**其中REDIS和EOF代表常量，其余代表变量**</code></pre><p>​        RDB文件开头是REDIS部分，这个部分的长度为5字节，保存”REDIS“五个字符，这相当于一个标识字段，Redis载入RDB文件最开始需要确认是否进行确认。db_version长度为4字节，是一个用字符串标识的整数，代表RDB文件的版本号。database部分包含0个或者任意对个数据库，已经数据库中的键值对数据。EOF是长度为1字节的常量，也是一个标识字段用于说明RDB正文内容的结束。check_sum的一个8字节长的无符号整数，保存一个校验和，这个校验和是程序通过对REDIS、db_version、database、EOF四个部分的内容计算得出的。服务器在载入RDB文件时，会将自如数据所计算的校验和与check_sum所记录的校验和比较，依此检查RDB文件是否有出错或者损坏情况。</p>
<p>​        以上可以总结为以下几点：</p>
<ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据</li>
<li>SAVE命令由服务器进程直接执行保存操作，执行期间会阻塞服务器</li>
<li>BGSAVE由子进程执行操作，该命令不会阻塞服务器</li>
<li>save选项配置可实现服务器自动执行BGSAVE，只需要其中任意一条件满足即可</li>
<li>RDB文件是一个经过压缩的二进制文件，由多部分组成</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>​        除了RDB持久化之外，Redis还支持AOF(Append Only File)持久化功能。与RDB生成数据库某一刻快照状态不同，AOF是通过保存Redis服务所执行的所有写命令记录数据库状态(并不是非常准确,一些影响服务器状态的命令也会被记录)。如对数据库执行SET、SADD、RPUSH等命令会被记录到AOF文件中。AOF中是以命令请求协议格式保存的，而命令请求协议格式是纯文本格式，所以我们可以直接打开一个AOF文件查看AOF文件。</p>
<p>​        AOF持久化实现可以分为：<strong>命令追加(append)、文件写入、文件同步三个步骤。</strong></p>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>​        Redis服务器执行完一个写命令后，会以协议格式将被执行命令追加到服务器状态的aof_buf缓存区的末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">// aof缓冲区</span></span><br><span class="line">   sds aof_buf;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p>​        Redis的设计是基于事件驱动，其服务器进程就是一个事件循环，这个循环中包含文件事件和时间事件，而时间事件负责执行像serverCron这样需要定时执行的函数。在Redis的主函数中是先执行文件事件，文件执行完成以后再执行时间时间，所以Redis中所有的定时任务都有可能延迟执行，并且只可能延迟不可能提前。在执行文件事件(socket连接的抽象)可能会执行写命令，使得一些命令写进aof_buf，所以每次循环结束之前服务器都会调用flushAppendOnlyFile函数，然后根据设置决定是否将aof_buf缓冲区内容写入和保存到AOF文件里面。以上过程可以用以下伪代码表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">eventloop</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">	<span class="keyword">while</span> True:</span></span><br><span class="line">		#处理文件事件，接受客户端发送的请求命令已经发送回复命令</span><br><span class="line">		#接受的请求命令可能会有新的内容被追加到aof_buf</span><br><span class="line">		processFileEvents()</span><br><span class="line">        #处理时间事件</span><br><span class="line">        procesTimeEvents()</span><br><span class="line">         	#考虑是否将aof_buf内容写入和保存到aof文件中</span><br><span class="line">            flushAppendOnlyFile()</span><br></pre></td></tr></table></figure>

<p>​        flushAppendOnlyFile的行为由服务器的appendfsync选项的值决定的，你可以理解为aof_buf缓冲区持久化方式是可配置的。</p>
<h4 id="文件的写入与同步"><a href="#文件的写入与同步" class="headerlink" title="文件的写入与同步"></a>文件的写入与同步</h4><p>​        在现代操作系统中，为了提高文件的写入效率，当用户调用write函数，将数据写入文件时，操作系统并不会立即执行写入操作，而是会将数据写入到一个内存缓冲区里面，等到缓冲区被填满或者触发写入机制的时候再开始真正的将数据持久化到磁盘。这种方式收益与风险并存，在提高写入效率的同时面临丢失数据的风险，为此操作系统为了让用户选择可承受范围，提供了fsync和fdatasync两个同步函数，它们可以实现立即将缓冲区中的数据写入到磁盘，从而确保数据的安全性。</p>
<h4 id="appendfsync可选项"><a href="#appendfsync可选项" class="headerlink" title="appendfsync可选项"></a>appendfsync可选项</h4><p>​        那么接着来讲appendfsync可选配置，可选项及其功能如下：</p>
<ul>
<li>always  服务器每个事件循环都要将aof_buf缓冲区的所有内容写入到AOF文件，并且同步AOF文件，所以always选项也是appendfsync可选配置中效率最慢的一个，但是从安全性考虑always是最安全的，即使发生故障重启，那么Redis也只会丢失一个事件循环中产生的写命令。</li>
<li>everysec  服务器每次事件循环都将aof_buf缓冲区的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。everysec也是appendfsync默认选项，其效率和安全性介于所有选择中间，发生故障重启后，Redis可能丢失故障前一秒内的命令数据。</li>
<li>no 服务器每次事件循环都将aof_buf缓冲区所有内容写入到AOF文件，至于何时对AOF文件进行同步，Redis完全不关心，只由操作系统决定。此时执行的flushAppendOnlyFile是不需要执行同步操作的，所以也是appendfsync所有可选项中最快的，同时也是最危险的，因为此选项模式下，发生故障重启后无法估计丢失写数据。</li>
</ul>
<h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>​        现在已经直到AOF文件中包含数据库状态的所有写命令，所以服务器只需要将AOF文件所有命令执行一遍即可还原数据库状态。事实上，Redis也是这么做的，并且载入AOF的优先级高于RDB文件，其步骤可以概括为以下几步：</p>
<ol>
<li>创建一个没有网络连接的伪客户端(fake client):因为Redis的命令只能由客户端发送，而现在载入AOF文件的所使用的命令来源于AOF文件并非网络连接，所以服务器需要创建一个伪客户端用于执行AOF文件中的命令。</li>
<li>开始从AOF文件中分析并读取一条写命令</li>
<li>使用伪客户端执行被读出的写命令</li>
<li>重复执行步骤2和步骤3直到AOF文件所有明白都被处理完毕</li>
</ol>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>​        AOF持久化是以写命令追加的方式实现，随着服务器的长时间运行，AOF文件体积必然会越来越大，一方面是新的键值对的写入，另一方面是对原有键值对的修改。如果不加以控制AOF文件可能对服务器甚至宿主机器造成影响，并且因为AOF文件过大，还原的事件也会越来越长。为了防止这种情况出现，Redis针对AOF文件做了一些优化，<strong>aof_rewrite</strong>函数实现对AOF文件的重写。</p>
<p>​        先描述一种现状再来讲述Redis优化的方向。比如客户端执行了以下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list &quot;A&quot; &quot;B&quot; &#x2F;&#x2F; list:[&quot;A&quot;,&quot;B&quot;]</span><br><span class="line">...</span><br><span class="line">RPUSH list &quot;C&quot; &#x2F;&#x2F; list:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]</span><br><span class="line">...</span><br><span class="line">RPUSH list &quot;D&quot; &quot;E&quot; &#x2F;&#x2F; list:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]</span><br><span class="line">...</span><br><span class="line">LPOP list &#x2F;&#x2F; list:[&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]</span><br><span class="line">...</span><br><span class="line">LPOP list &#x2F;&#x2F; list:[&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]</span><br><span class="line">...</span><br><span class="line">RPUSH list &quot;F&quot; &quot;G&quot; &#x2F;&#x2F; list:[&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;]</span><br></pre></td></tr></table></figure>

<p>​        以上命令在AOF文件中光是list键就多达六条，这种情景在我们的业务系统中也是很常见的，所以可以看出AOF文件中其实记录了很多针对同一个键的写命令。为了解决AOF文件体积膨胀问题，Redis提供了AOF重写功能：Redis创建一个新的AOF文件来替换现有的AOF文件，新旧AOF文件所保存的数据库状态一致，但是新的AOF文件没有任何浪费空间的冗余命令，所以新的AOF文件体积要小的多。</p>
<p>​        <strong>AOF重新的实现并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前数据状态来实现。</strong>所以上述list在新的AOF文件中只会保存一条命令：<strong>RPUSH list “C” “D” “E” “F” “G”</strong>,这种用一条命令替换旧AOF文件中多条命令的实现就是AOF重写。需要注意的是，并不是所有key的命令都只用一条命令替换，考虑到客户端输入缓冲区是由大小限制的(最大为1G)，极端情况下会出现缓冲区溢出，所以针对列表、哈希表、集合、有序集合中的key，AOF重写可能用两条甚至多条命令(一定会小于旧AOF文件key的命令)替代。参数REDIS_AOF_REWRITE_ITEMS_PER_CMD常量就是用来控制AOF重新中包含多个元素key的长度，默认64，即超过64个元素即使发生AOF重写也需要用至少两条命令。</p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>​        上面介绍的aof_rewrite函数，通过生成新的没有任何浪费空间的AOF文件，可以很好的解决AOF文件膨胀问题，但是在执行aof_rewrite函数之后会在短时间内执行大量的写入操作，所以调用这个函数的线程会被长时间阻塞，因为Redis是单线程设计，如果主线程调用aof_rewrite函数，那么在重写AOF期间服务器是不能处理客户端发送的请求命令。Redis显然不运行因为某些功能上的优化影响核心的服务，所以Redis实际上是将AOF重写放到子进程中执行的，这样做可以同时达到两个目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程正常处理客户端请求命令，对于客户端而言，像是什么都没发生一样</li>
<li><strong>子进程带有服务器进程的数据副本，使用子进程而不是子线程可以在避免在使用锁的情况下，保证数据的安全性</strong>。</li>
</ul>
<p>​        但仅仅做到这些是不够，又会出现新的问题。因为子进程中保存的是aof_rewrite函数开始执行的某一刻的数据副本，子进程在进行AOF重写的过程中，服务器主进程也在接受客户端发送请求命令，所以会出现子进程重写的AOF文件还原的数据库状态和实际状态不一致，原因就是因为子进程少了在其进行AOF重写那段时间的写命令造成数据不一致。</p>
<p>​        为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用。主服务器在执行完客户端发送的请求命令之后，会将这条命令发送到AOF缓冲区和AOF重写缓冲区。也就是说AOF重写期间服务器主线程做了三件事情：</p>
<ol>
<li>执行客户端发来的命令</li>
<li>将执行写完成的命令追加到AOF缓冲区</li>
<li>将执行的写命令追加到AOF重写缓冲区。</li>
</ol>
<p>​        当子进程完成AOF重写工作之后，它会向父线程发送一个信号，父线程接收到该信号后会调用一个信号处理函数，注意，AOF重写过程中有且只有在该信号处理器执行时会对Redis服务器阻，然后开始执行以下工作：</p>
<ol>
<li><p>将AOF重写缓冲区的所有内容写入新的AOF文件中，这时新的AOF文件所保存的数据库状态将和服务器当前状态一致</p>
</li>
<li><p>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，成功之后AOF重写完成</p>
<p>以上就是AOF后台重写实现过程，也是BGREWRITEAOF命令的实现原理。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/" data-id="ckb0d4uwu0001f8r63x08h0h8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一行一行看AQS源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E7%9C%8BAQS%E6%BA%90%E7%A0%81/" class="article-date">
  <time datetime="2020-06-04T05:06:36.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E7%9C%8BAQS%E6%BA%90%E7%A0%81/">一行一行看AQS源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        它提供了一个FIFO队列，可以看成是一个用来实现同步锁以及其他涉及到同步功能的核心组件，常见的有:ReentrantLock、CountDownLatch等。<br>​        AQS是一个抽象类，主要是通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取以及释放的方法来提供自定义的同步组件。</p>
<p>​        AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch)。不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了</p>
<p>核心数据结构：双向链表+state(int 锁状态)</p>
<p>底层操作：CAS</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">// 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</span></span><br></pre></td></tr></table></figure>

<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared</p>
<h2 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>独占模式下获取锁(可以理解为尝试修改共享变量state的抽象行为)，忽略中断，内部通过调用tryAcquire(arg)尝试修改state，修改成功直接返回。否则线程加入FIFO双向队列，AQS将当前线程封装为一个独占模式的Node节点，在线程找到合适的前驱节点之后调用unpark()进入waiting状态，等待被唤醒之后再次尝试获取锁，如果失败继续进入等待。</code></pre><p>Node节点结构如下:</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; <span class="comment">// 取消</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; <span class="comment">// 唤醒后驱节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; <span class="comment">// 节点等待在condition上，等待被唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; <span class="comment">// 共享模式下，前驱节点不仅唤醒后驱节点，有可能会唤醒后驱节点的后驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 节点状态</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev; <span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;<span class="comment">//当前线程</span></span><br><span class="line">        Node nextWaiter; <span class="comment">//存储在condition队列中的后继节点</span></span><br><span class="line">        <span class="comment">//是否为共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将线程构造成一个Node，添加到等待队列</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个方法会在Condition队列使用</span></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
<li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li>0：新结点入队时的默认状态。</li>
<li><strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong></li>
</ul>
<h4 id="ReentrantLock中非公平锁的tryAcquire实现"><a href="#ReentrantLock中非公平锁的tryAcquire实现" class="headerlink" title="ReentrantLock中非公平锁的tryAcquire实现"></a>ReentrantLock中非公平锁的tryAcquire实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果c==0，说明锁未被占有</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// hasQueuedPredecessors()返回false表示要尝试获取锁</span></span><br><span class="line">        <span class="comment">// 获取到锁之后cas修改state</span></span><br><span class="line">        <span class="comment">// 以上两步都成功之后将当前锁的持有者设置为自己，返回true,开始执行lock()方法接下来的临界代码</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程正是锁的持有者，可重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// state+重入次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 异常检测</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// cas设置state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        tryAcquire返回true，表示成功获取到锁，false代表获取锁失败，需要进入等待队列</p>
<h5 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h5><p>​        此方法判断当前线程是否需要尝试获取锁，返回false表示可以获取，true表示不可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.如果t==h，直接返回false。此时t和h为具体的同一个node或者null,不管到底是node还是null，当前线程都可以尝试获取锁，因为即使t==h==node,也不能断定node是否持有锁，而且当前线程没有进入等待状态，所以有必要去尝试获取锁</span></span><br><span class="line"><span class="comment">// 2.如果t!=h，接着判断h.next==null，看似很不可思议，明明h和t不相同,那么h.next!=null才对，实际上h.next是有可能等于null的。如果这个时候刚好有一个线程第一次入队，进入enq()方法，并且已经执行了compareAndSetHead(node)，但并未执行到tail=head时，此时head.next==null，同时也说明这个线程正在持有锁，hasQueuedPredecessors()返回true,此线程不需要尝试获取锁。</span></span><br><span class="line"><span class="comment">// 3.如何h!=t,并且h.next!=null,紧接着判断s.thread!=Thread.currentThread(),同样看上去有些多余，因为既然h.next!=null,那么肯定会在队列里进入waiting状态，这时候判断当前线程是否就是h.next的线程显得有些多余。实际上也并非如此，想象一下，假如当前线程刚刚被头节点唤醒,而且刚好是头节点的后驱节点,此时是在acquireQueued方法中的for(;;)中的,紧接着马上会执行到tryAcquire(),那么再次进入hasQueuedPredecessors()中时s.thread!=Thread.currentThread()是成立,并且返回false。</span></span><br></pre></td></tr></table></figure>

<h4 id="addWaiter-Node-node"><a href="#addWaiter-Node-node" class="headerlink" title="addWaiter(Node node)"></a>addWaiter(Node node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一步失败则通过enq入队</span></span><br><span class="line">    enq(node); <span class="comment">// 自旋，直到入队为止</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enq-final-Node-node"><a href="#enq-final-Node-node" class="headerlink" title="enq(final Node node)"></a>enq(final Node node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// new Node() 没有实际对应任何线程</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h4><p>​        进入等待的线程在其他线程彻底释放资源后唤醒自己去获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 标记等待过程中是否被中断过</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 自旋的方式获取队列中等待线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前node的前驱节点</span></span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="comment">// 如果前驱节点为头节点，尝试获取锁，此时有可能是前驱节点释放锁之后唤醒自己，也有可能被interrupt</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 获取成功将自己设置为头节点</span></span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;<span class="comment">// 返回等待过程中是否被中断过</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 可以进入堵塞状态，通过park()进入waiting直到被unpark(),如果被中断，醒来之后拿不到资源再次进入park()等待</span></span><br><span class="line">     <span class="comment">// 只有在前置节点是正常等待状态，自己才能进入等待装药</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            <span class="comment">// 等待过程中被中断</span></span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待</span></span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="shouldParkAfterFailedAcquire-Node-pred-Node-node"><a href="#shouldParkAfterFailedAcquire-Node-pred-Node-node" class="headerlink" title="shouldParkAfterFailedAcquire(Node pred, Node node)"></a>shouldParkAfterFailedAcquire(Node pred, Node node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前驱节点的状态</span></span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">     * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 前驱节点释放锁后会主动唤醒当前节点node</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">     * indicate retry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果前驱节点已取消，那就一直往前找，直到找到前驱节点为正常等待状态的，并排在其后</span></span><br><span class="line">    <span class="comment">// 中间放弃的节点由于自己加塞到了它们前面，实际上形成了无用的引用链，稍后它们就会被GC回收</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态为0或者PROPAGATE(-3)，设置前驱的等待状态为SIGNAL,</span></span><br><span class="line"><span class="comment">         * 并且之后会回到循环再次重试获取锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程进入waiting状态</span></span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 如果被唤醒查看是否被中断</span></span><br></pre></td></tr></table></figure>

<h4 id="acquire-小结"><a href="#acquire-小结" class="headerlink" title="acquire()小结"></a>acquire()小结</h4><ol>
<li>调用自定义同步器的tryAcquire()尝试修改state状态，如果成功直接返回</li>
<li>修改失败，addWaiter()将该线程加入等待队列，并标记为独占模式</li>
<li>线程调用acquireQueued()在等待队列中找到合适的waiting位置，前驱节点唤醒该线程之后，并返回等待过程是否被中断标志，之后重复步骤1</li>
<li>线程在等待过程中不响应中断，在获取资源之后自我中断selfInterrupt(),将中断补上。</li>
</ol>
<h2 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h2><p>​        独占模式下释放资源的顶层接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁资源(修改共享变量state)</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 获取头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 此时的head节点可能有3种情况:</span></span><br><span class="line"><span class="comment">         * 1. null (AQS的head延迟初始化+无竞争的情况)</span></span><br><span class="line"><span class="comment">         * 2. 当前线程在获取锁时new出来的节点通过setHead设置的</span></span><br><span class="line"><span class="comment">         * 3. 由于通过tryRelease已经完全释放掉了独占锁，有新的节点在acquireQueued中获取到了独占锁，并设置了head</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后驱节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h4><p>​        唤醒等待队列的下一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取自己的waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 相当于释放锁</span></span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 找到下一个需要唤醒的结点s</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果为空或已取消</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>; <span class="comment">//help gc</span></span><br><span class="line">    <span class="comment">// 从队尾向前找有效节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 唤醒，需要注意的是如果在此之前该线程被kill，那么队列中的永远无法被唤醒。如果代码正常运行还是能够保证成功执行unpark()方法，另外线程在运行状态不会响应中断</span></span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line"><span class="comment">//s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了</span></span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock中非公平锁的tryRelease实现"><a href="#ReentrantLock中非公平锁的tryRelease实现" class="headerlink" title="ReentrantLock中非公平锁的tryRelease实现"></a>ReentrantLock中非公平锁的tryRelease实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改共享变量state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是独占state的持有者，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 定义释放标志</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 独占线程置空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set共享变量</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 这个状态一定要返回</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="release-小结"><a href="#release-小结" class="headerlink" title="release()小结"></a>release()小结</h4><p>​        release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源</p>
<h2 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h2><p>​        此方法是共享模式下获取共享资源的顶层方法，获取指定数量的资源，如果成功直接返回。获取失败进入等待队列，直到获取到为止，整个过程忽略中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取失败,进入等待</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Semaphore中非公平锁的tryAcquireShared-实现"><a href="#Semaphore中非公平锁的tryAcquireShared-实现" class="headerlink" title="Semaphore中非公平锁的tryAcquireShared()实现"></a>Semaphore中非公平锁的tryAcquireShared()实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 非公平模式实现</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 区别于独占模式,共享模式不需要判断是否能够获取锁</span></span><br><span class="line">      <span class="comment">// 自旋+cas获取锁 </span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 这里的availabe是Semaphore的构造方法传入值</span></span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="comment">// state小于表示获取失败,大于0表示成功</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h4><p>​        将当前线程放入队列尾部等待，直到被唤醒并获取到指定数目资源后返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 是否获取成功的标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否被中断的标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点,需要注意的是前驱节点为空，直接npe，所以p一定不为null</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点为头节点,表示本线程可以尝试获取锁</span></span><br><span class="line">                <span class="comment">// 因为头节点在任意时刻都可能为持有锁或者释放锁状态，所以其后置节点如果不在waiting状态</span></span><br><span class="line">                <span class="comment">// 都要尝试去获取锁</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里表示获取锁成功，将自己指向头节点，如果还有剩余资源唤醒后驱节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">// 如果等待过程中被中断过，此时将中断补上。</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断状态，寻找合适的前驱节点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果try()中出现异常，取消正在进行的获取尝试</span></span><br><span class="line">        <span class="comment">// node.predecessor可能抛出npe</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="setHeadAndPropagate-node-propagate"><a href="#setHeadAndPropagate-node-propagate" class="headerlink" title="setHeadAndPropagate(node, propagate)"></a>setHeadAndPropagate(node, propagate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的头节点</span></span><br><span class="line">Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line"><span class="comment">// 将当前获取到锁的节点设置为头节点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">// 如果propagate &gt; 0表示仍有剩余共享资源，需要唤醒后驱节点尝试获取</span></span><br><span class="line"><span class="comment">// 这里分别判断了旧头节点和新头节点的是否为null,这是有可能发生的，比如在别的线程中头节点被释放，这时候同样也需要去唤醒后驱节点</span></span><br><span class="line"><span class="comment">// 需要注意的是前驱节点的waitStatus&lt;0 是后驱节点设置的，用来提醒前驱节点获取到锁以后要唤醒后面的节点</span></span><br><span class="line"><span class="comment">// 所以这里分别检查了旧头节点的和新的头节点的waitStatus,如果小于0表示后驱需要唤醒</span></span><br><span class="line"><span class="comment">// 在propagate&lt;=0的情况下仍尽可能唤醒后驱节点,这样做的好处应该是为了提高并发，虽然现在没有资源可取，但是把后驱先唤醒，在共享资源释放之后能够立即获取</span></span><br><span class="line"><span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">    (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 检查后驱节点是否为共享模式</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Node之所以出现PROPAGATE状态原因就在这里，早期是没有h.waitStatus&lt;0的判断，</span></span><br><span class="line"><span class="comment">* 只有propagate &gt; 0，不能解决共享锁并发释放导致的线程hang住问题</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 排除队列初始化状态</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">        <span class="comment">// 需要唤醒后驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// cas修改waitingStatus=0,代表head已经不需要等待了(当前线程即为head)</span></span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">            <span class="comment">// 唤醒后驱</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次循环进入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 将头节点cas设为PROPAGATE</span></span><br><span class="line">                 !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">            <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后判断头节点是否被改变，如果是，继续自旋</span></span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cancelAcquire-node"><a href="#cancelAcquire-node" class="headerlink" title="cancelAcquire(node)"></a>cancelAcquire(node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// node的线程引用置空</span></span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 前驱节点</span></span><br><span class="line">Node pred = node.prev;</span><br><span class="line"><span class="comment">// 找到没有取消的前驱节点</span></span><br><span class="line"><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line"><span class="comment">// 前驱节点的后驱节点</span></span><br><span class="line">Node predNext = pred.next;</span><br><span class="line"><span class="comment">// 当前节点状态改为取消</span></span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line"><span class="comment">// 如果node是tail，将上面的前驱节点更新为tail，并使pred.next指向null</span></span><br><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    <span class="comment">// 这里失败也没关系说明存在并发，总归有一个会成功的</span></span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果node既不是tail，又不是head的后继节点</span></span><br><span class="line">        <span class="comment">// 则将node的前继节点的waitStatus置为SIGNAL</span></span><br><span class="line">        <span class="comment">// 并使node的前继节点指向node的后继节点</span></span><br><span class="line">    <span class="keyword">int</span> ws;</span><br><span class="line">    <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">        ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">         (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; </span><br><span class="line">        pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            compareAndSetNext(pred, predNext, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 这时说明pred == head或者pred状态取消或者pred.thread == null</span></span><br><span class="line"><span class="comment">            * 在这些情况下为了保证队列的活跃性，需要去唤醒一次后继线程。</span></span><br><span class="line"><span class="comment">            * 举例来说pred == head完全有可能实际上目前已经没有线程持有锁了，</span></span><br><span class="line"><span class="comment">            * 自然就不会有释放锁唤醒后继的动作。如果不唤醒后继，队列就挂掉了。</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 这种情况下看似由于没有更新pred的next的操作，队列中可能会留有一大把的取消节点。</span></span><br><span class="line"><span class="comment">            * 实际上不要紧，因为后继线程唤醒之后会走一次试获取锁的过程，</span></span><br><span class="line"><span class="comment">            * 失败的话会走到shouldParkAfterFailedAcquire的逻辑。</span></span><br><span class="line"><span class="comment">            * 那里面的if中有处理前驱节点如果为取消则维护pred/next,踢掉这些取消节点的逻辑。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = node; <span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁，并发环境下cas操作有可能失败</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒后驱节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Semaphore中tryReleaseShared-实现"><a href="#Semaphore中tryReleaseShared-实现" class="headerlink" title="Semaphore中tryReleaseShared()实现"></a>Semaphore中tryReleaseShared()实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到的共享资源还回去，加到state上面</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS总结"><a href="#AQS总结" class="headerlink" title="AQS总结"></a>AQS总结</h2><p>​        AQS为JUC中并发工具提供了完美的框架，精妙而又优雅的实现了并发中多线程在获取锁失败之后的从入队到出队过程，在此基础之上支持两种持有锁的方式：独占式和共享式。两者在唤醒后驱节点的实现上有明显的区别，前者只需要后驱节点重新获取锁，后者需要考虑剩余的共享资源，为了更好的支持并发会唤醒后继所有的共享模式节点。总之，AQS绝对是伟大之作，值得每隔一段时间回过头重新去感悟其中的实现细节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E7%9C%8BAQS%E6%BA%90%E7%A0%81/" data-id="ckb0bk57p0000z4r62ogz6sw8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java线程实现与synchronized锁优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8Esynchronized%E9%94%81%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2020-06-04T04:54:59.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8Esynchronized%E9%94%81%E4%BC%98%E5%8C%96/">Java线程实现与synchronized锁优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>​        线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配合执行调度分开，各个线程既可以共享进程资源，如内存地址、I/O等，又可以独立调度。目前线程是Java进行处理器资源的最基本单位。Java语言提供了在不同硬件和操作系统下对线程操作的统一处理，每个已经调过start()方法并且还未结束的java.lang.Thread类的实列就代表一个线程，Thread类与大部分Java类库的API有显著的差别，它的所有关键方法都被声明为Native,一个Native方法往往意味着这个方法没有使用或无法使用平台无关性手段实现。</p>
<p>​        线程主要有三种实现方式：1.使用内核线程实现(1:1实现)，2.使用用户线程实现(1:N实现)，3.使用用户线程和轻量级进程混合实现(N:M实现)。</p>
<h5 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1.内核线程实现"></a>1.内核线程实现</h5><p>​        内核线程就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同事处理多件事情，支持多线程的内核就称为多线程内核。</p>
<p>​        程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口，叫做轻量级进程，这也是我们通常意义上所讲的线程，每个轻量级进程都由一个内核线程支持，这种轻量级进程与内核线程之间1:1的关系称为一对一线程模型。</p>
<p>​        优势：每个轻量级进程都成为一个独立的调度单元，即使其中一个轻量级进程在系统调度中被堵塞也不会影响整个进程继续工作。局限性：由于是基于内核线程实现的，所有各种线程操作，比如创建、析构和同步，都需要进行系统调用(system call),而系统调用的代价相对较高，需要在内核态和用户态之间来回切换(每次切换内核都需要保存上下文资源，恢复下个线程上次执行所在现场)。每个轻量级进程需要内核线程的支持，因此轻量级进程需要消耗内核资源，所以一个系统支持的轻量级进程是有限的。</p>
<h5 id="2-用户线程实现"><a href="#2-用户线程实现" class="headerlink" title="2.用户线程实现"></a>2.用户线程实现</h5><p>​        使用用户线程实现的方式被称为1:N实现。广义上来讲，只要不是内核线程，其余都是用户线程，所以轻量级进程也可以被称为用户线程，但是轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受限制，不具备通常意义上用户线程的优点。</p>
<p>​        用户线程指的是完全建立在用户空间的线程库上，系统内核不用感知到用户线程的存在及如何实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不要内核的帮助。如果实现得到，这种线程不需要内核态和用户态之间切换，因此操作可以是非常快且低消耗的，也能支持更大规模的线程数量，部分高性能数据中的多线程就是用户线程实现，这种进程与用户线程之间1:N的关系称为一对多线程模型。</p>
<p>​        优势:不需要内核支援。劣势：没有内核支持，所有的线程操作都需要用户程序实现。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，诸如“堵测如何处理”，“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起立将会异常困难甚至无法实现，一般的应用程序都不倾向于使用用户线程。</p>
<h5 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3.混合实现"></a>3.混合实现</h5><p>​        除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式叫做混合实现，也被成为N:M实现。在这种混合实现下，既存在用户线程又存在轻量级进程。用户线程还是建立在用户空间之上，线程的创建、切换、析构等操作依然廉价，但是由于轻量级进程的存在使得内核提供的线程调度功能及处理器映射变得简单许多，在这种混合模式下，用户线程和内核线程的数量比是不定的，是N:M的关系，这种就是多对多模型。</p>
<h4 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h4><p>​        首先需要明确的是，Java线程的实现并不受Java虚拟机的约束，这是与具体虚拟机无关的话题。Java线程早期(JDK1.2以前)是基于一种“绿色线程”的用户线程实现的，从JDK1.3起，主流商用Java虚拟机的线程模型普遍被替换成基于操作系统原生线程模型来实现，即采用了1:1模型。以HotSpot为例，它的每一个线程都是直接映射到一个操作系统的原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot不会去干涉线程调度，线程所有的一切行为底层都是由操作系统全权决定。</p>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>​        调度是指系统为线程分配处理器使用权的过程，调度主要分为两种，分别是协同式和抢占式。</p>
<p>​        协同式：线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上去。协同式最大的好处就是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程是可知的，所以一般不会存在线程同步问题。这种方式的坏处也明显：线程执行时间不可控，如果线程代码编写有问题，一直不告知系统进行线程切换，那么程序会一直堵塞在那里。</p>
<p>​        抢占式：每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定。如Thread.yield()方法可以让线程主动让出执行时间，但是如果线程想要主动获取执行时间，线程本身是没有什么办法的。这种调度的实现下，执行时间是可控的。<strong>Java使用的调度方式就是抢占式调度</strong>。</p>
<p>​        虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多一点执行时间，另外的线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java共设置了10个级别的优先级，在两个线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行，但这并不是万无一失的，因为主流虚拟机上的Java线程是被映射到操作系统原生线程之上的，所以线程调度最终还是由操作系统说了算。尽管现代操作系统都提供了线程优先级概念，但不见得能与Java线程的优先级一一对应，如Solaris中线程有2147483648(2的31次幂)种优先级，但windows只有7种，如果操作系统比Java优先级更多，那还比较容易处理，中间留出空位就可以了，但是如果操作系统优先级比Java线程优先级少了，那一定会出现多个Java不同的优先级对应到操作系统同一个优先级的情况了，所以Java线程的优先级并不是高优先级绝对比低优先级先获取到cpu时间片。</p>
<h3 id="Java线程状态转换"><a href="#Java线程状态转换" class="headerlink" title="Java线程状态转换"></a>Java线程状态转换</h3><p>​        Java定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中一种状态。这6种状态分别是：</p>
<ul>
<li><input disabled type="checkbox"> <p>新建(New)：创建后尚未启动的线程处于这种状态</p>
</li>
<li><input disabled type="checkbox"> <p>运行(Runnable)：映射到操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待操作系统为它分分配执行时间。</p>
</li>
<li><input disabled type="checkbox"> <p>无限期等待(Waiting)：处于这种状态的线程不会被分配到处理器执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程进入无限期等待状态：</p>
<ol>
<li>没有设置Timeout参数的Object::wait()方法</li>
<li>没有蛇者Timeout参数的Thread::join()方法</li>
<li>LockSupport::park()方法</li>
</ol>
</li>
<li><input disabled type="checkbox"> <p>限期等待(Timeout waiting)：处于这种状态的线程也不会被分配到处理器执行时间，不过无须等到其他线程的唤醒，在指定时间之后它们会被系统自动唤醒，以下方法会让线程进入限期等待：</p>
<ol>
<li>Thread::sleep()方法</li>
<li>设置了Timeout参数的Object::wait()方法</li>
<li>设置了Timeout参数的Thread::join()方法</li>
<li>LockSupport::parkNanos()方法</li>
<li>LockSupport::parkUntil()方法</li>
</ol>
</li>
<li><input disabled type="checkbox"> <p>阻塞(Blocked)：线程被堵塞了，“堵塞状态”与“等待状态”的区别是“堵塞状态”在等待着获取到一个排他锁，这个时间将在另外一个线程释放锁的时候发生，而“等待状态”则是等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程进入这种状态。</p>
</li>
<li><input disabled type="checkbox"> <p>结束(Terminated)：已终止的线程状态，代表线程已经执行结束。</p>
<p>转换图如下：</p>
</li>
</ul>
<img src="/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8Esynchronized%E9%94%81%E4%BC%98%E5%8C%96/Users\wb-sqk632770\AppData\Roaming\Typora\typora-user-images\image-20200529114237565.png" alt="image-20200529114237565" style="zoom:80%;">



<h3 id="Java线程安全的实现方法"><a href="#Java线程安全的实现方法" class="headerlink" title="Java线程安全的实现方法"></a>Java线程安全的实现方法</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>​        互斥同步是一种最常见的也是最主要的并发正确性保障手段。同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一条线程使用(或者是一些，当使用信号量的时候)。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。在Java里最基本的互斥手段就是synchronized关键字。</p>
<h5 id="synchronized实现同步的原理"><a href="#synchronized实现同步的原理" class="headerlink" title="synchronized实现同步的原理"></a>synchronized实现同步的原理</h5><p>​        synchronized，Java关键字。互斥锁，可重入锁，隐式锁，重量级锁(早期是这样的)，一种块结构的同步语法。是JVM层面提供的一种解决线程安全的实现方法。synchronized经过Javac编译之后，会在同步代码块的前后分别形成<strong>monitorenter</strong>和<strong>monitorexit</strong>这两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象，如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference,如果没有明确指定，那就根据synchronized修饰的方法类型(实例方法或静态方法)，来决定是取代码所在的而对象实例还是取类型对应的Class对象作为线程要持有的锁。当synchronized修饰方法时，代码块的前后不需要使用monitorenter和monitorexit指令，而是在方法的符号引用添加<strong>ACC_SYNCHRONIZED</strong>标识。</p>
<p>​        根据《Java虚拟机规范》的要求，在执行<strong>monitorenter</strong>指令时，首先要尝试获取对象的锁，如果对象此时没有被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值加一，而在执行<strong>monitorexit</strong>指令时会将计数器的值减一，一旦计数器的值为零，锁随即被释放，如果获取锁对象失败，那当前线程就应当被阻塞等待，直到请求的锁定的对象被持有它的线程释放为止。据此我们可以得出关于synchronized的两条结论：</p>
<ul>
<li><input disabled type="checkbox"> 被synchronized修饰的代码块对同一条线程来说是可重入的，这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li><input disabled type="checkbox"> 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入，这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁，也无法强制正在等待锁的线程中断等待或者超时退出。</li>
</ul>
<p>​       synchronized是重量级锁体现在锁的获取和释放都需要经过内核态和用户态之间的转换，随着JDK版本的升级，Java虚拟机对这个“亲生儿子”也做了一系列优化，譬如在获取锁失败之后并不会立马进入阻塞状态，而是尝试通过自旋再次获取锁，避免“双态”之间频繁切换，关于synchronized的锁优化后续补充。</p>
<h5 id="ReentrantLock实现同步"><a href="#ReentrantLock实现同步" class="headerlink" title="ReentrantLock实现同步"></a>ReentrantLock实现同步</h5><p>​        除了synchronized，自JDK1.5起，Java类库中提供了java.util.concurrent包(简称JUC),其中的java.util.concurrent.locks.lock接口编程了Java另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现同步互斥，摆脱语言的束缚，在API层面实现同步。</p>
<p>​        重入锁(ReentrantLock)是Lock接口最常见的一种实现，意为其名，它和synchronized一样都是可重入的，同为悲观锁，与其不同的是ReentrantLock的使用需要程序员关注锁的获取和释放，所以其又为显示锁。相比较synchronized,ReentrantLock增加了一些高级功能，主要包括以下三项：</p>
<ul>
<li><input disabled type="checkbox"> <p><strong>等待可中断</strong>：指持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</p>
</li>
<li><input disabled type="checkbox"> <p><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁，synchronized中的锁是非公平的，ReentrantLock默认也是非公平锁，通过构造方法传入布尔值可使用公平锁，不过一旦使用了公平锁会导致ReentrantLock性能急剧下降，明显影响吞吐量(内部通过维护队列实现)。</p>
</li>
<li><input disabled type="checkbox"> <p><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象，在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外添加一个锁，而ReentrantLock无须这样做，只需要多次调用newCondition()方法即可。</p>
</li>
</ul>
<p>  如果需要使用上述功能，ReentrantLock是一个很好的选择，如果是基于性能考虑呢？</p>
<h5 id="synchronized与ReentrantLock性能比较"><a href="#synchronized与ReentrantLock性能比较" class="headerlink" title="synchronized与ReentrantLock性能比较"></a>synchronized与ReentrantLock性能比较</h5><p>​        在JDK1.5之前synchronized对性能的影响还是很明显的，为此在JDK1.6中还专门针对性的优化，以synchronized和ReentrantLock的性能对比为例，Brian Goets对这两种锁在JDK5环境下做了一组吞吐量对比的实验，实验结果如下图</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure1.jpg" alt="Figure 1. Throughput for synchronization and Lock, single CPU"></p>
<p>​                                                                               JDK5、单核处理器下两种锁的吞吐量对比</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure2.jpg" alt="Figure 2. Throughput (normalized) for synchronization and Lock, four CPUs"></p>
<p>​                                                                              JDK1.5、双核处理器下两种锁的吞吐量对比</p>
<p>​        上图看出，多线程环境下synchronized的吞吐量下降地非常严重，也说明了synchronized还有非常大地优化余地，当然后续技术也证明了这点，当JDK1.6加入了大量针对synchronized锁地优化措施之后，相同的测试中就发现synchronized与ReentrantLock的性能基本上能够持平，着眼于当下，无论是企业开发还是学习使用我们的JDK版本应该都在1.6之上，所以性能已经不再是选择synchronized或者ReentrantLock的决定因素。</p>
<p>​        基于以下理由，在synchronized和ReentrantLock都能满足需要时推荐优先使用synchronized：</p>
<ul>
<li><input disabled type="checkbox"> synchronized是Java语言层面的同步，足够清晰，也足够简单。每个程序员都熟悉synchronized，而J.U.C中的Lock接口并非如此。</li>
<li><input disabled type="checkbox"> Lock要确保在finally块中释放锁，否则一旦同步块抛出异常，则有可能永远不会释放持有的锁，这一点必须有程序员保证，而使用synchronized我们不需要关心持有锁的获取和释放,JVM来确保即使出现异常，锁也能被自动释放。</li>
<li><input disabled type="checkbox"> 长远角度来看，synchronized作为JVM的“亲儿子”更容易对其进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而在Lock中Java虚拟机很难得知哪些锁对象是由特定线程持有的。</li>
</ul>
<h4 id="非堵塞同步"><a href="#非堵塞同步" class="headerlink" title="非堵塞同步"></a>非堵塞同步</h4><p>​        互斥同步面临的主要问题就是进行线程阻塞和唤醒所带来的性能开销，因此互斥同步也被成为阻塞同步。从策略上来看，互斥同步属于悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现线程安全问题。随着硬件指令集的发展，我们已经有了另外一种选择：<strong>基于冲突检测的乐观并发策略。</strong>通俗来讲，就是不管风险，先进行操作，颇有“先斩后奏”之意。如果没有其他线程争用共享数据，那操作就直接成功；如果共享数据被争用，产生了冲突，再进行补救措施，最常见的补救措施就是不断地重试，直到出现没有竞争共享数据为止。这种乐观并发策略不需要将线程阻塞挂起，因此被称为非堵塞同步。</p>
<p>​        需要注意的是，乐观并发策略需要“硬件指令集的支持”，因为我们必须要求检测操作和冲突检测都是原子性操作。靠什么保证原子性？如果我们再使用互斥同步来促进保证就失去了讨论非堵塞同步的意义，所以只能靠硬件来实现这件事情。硬件来保证某些从语义上看起来像是需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li><input disabled type="checkbox"> 测试并设置(Test-and-Set)</li>
<li><input disabled type="checkbox"> 获取并增加(Fetch-and-Increment)</li>
<li><input disabled type="checkbox"> 交换(Swap)</li>
<li><input disabled type="checkbox"> <strong>比较并替换(Compare-and-Swap,又称CAS)</strong></li>
<li><input disabled type="checkbox"> 记载链接/条件储存(Load-Linked/Store-Conditional,又称LL/SC)</li>
</ul>
<p>​      前三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能也类似的。在x86、IA64指令集中有用<strong>cmpxchg</strong>(<strong>关键的指令，synchronized和CAS底层实现都是依靠 lock cmpxchg指令配合完成的</strong> )指令完成的CAS功能。</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>​        CAS指令需要有三个参数，分别是内存位置(可以理解为Java对象的内存地址，用V表示)、旧的预期值(用A表示)和准备设置的新值(用B表示)，CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。但是，不管释放更新V的值，都会返回V的值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</p>
<p>​        在JDK1.5之后，Java类库中才开始使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等接方法包装提供，HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以让认为是无条件内联过去了。Unsafe在设计上就不是提供给用户程序使用的(Unsafe::getUnsafe()的代码中限制了只有启动类加载器(Bootstrap ClassLoader)加载的class才能访问它)，因此在JDK9之前只有Java类库能够使用CAS,例如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。用户程序如果需要使用CAS操作，可以采用反射手段突破Unsafe的访问限制。</p>
<p>​        尽管CAS看起来很美好，既简单又高效，但是显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来讲并不是真正的完美，它存在一个逻辑漏洞：ABA问题，即一个变量V初次读取的值为A，并且准备赋值的时候它仍然为A值，那也不能说明V没有被改变过，又能赋值时候的读取实际上是别的线程已经修改后的A值，CAS操作会误认为它从来没有被改变过。J.U.C包为了解决这个问题，体提供了一个带有标记的原子引用类AtomicStampedReference,它通过控制变量值的版本来保证CAS的正确性。CAS另外一个缺点就是在高并发的场景表现会十分糟糕，因为大量线程自旋重试会占用过多的系统资源最后导致程序OOM。</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>​        要保证线程安全，并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就涉及共享数据，那自然就不需要任何同步措施去保证其正确性。Java中有些代码天生是线程安全的。</p>
<p>​        可重入代码：又称纯代码，可以在代码执行的任意时刻中断，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误，也不对对结果有所影响。可重入代码有一些特性，例如不依赖全局变量，存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非重入的方法等，我们可以通过一个比较简单的原则判断代码是否具体可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那么既满足可重入的要求，当然也是线程安全的。</p>
<p>​        线程本地存储：如果一段代码中所需要的而数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证我们就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据争用的问题。我们最熟悉的java.lang.ThreadLocal类就可以实现本地存储功能。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>​        高效并发是从JDK1.5升级到JDK1.6后一项重要的改进项，HotSpot虚拟机开发团队花费了大量资源去实现各种锁优化技术，如<strong>适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁</strong>等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题。从此以后synchronized地性能有了质地提升。</p>
<h4 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h4><p>​        前面已经讲过互斥锁最大地问题在于阻塞的实现、挂起线程和恢复线程的操作都需要转入内核态完成。这给Java虚拟机的并发性带来很大的压力，同时，虚拟机团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这很短的时间取挂起和恢复线程付出的代价实在太大了点，我们不妨让请求锁的对象在原地”稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程“等待”，我们只须让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁，实际上只是一种逻辑加锁，物理上并没有实现加锁的方式。</p>
<p>​        自旋等待不代表阻塞，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果会很好，反之，如果锁占用时间很长，那么自旋的线程只会白白消耗处理器资源，不会做有价值的工作。自旋可以通过-XX:+UseSpining参数开启，次数默认是10次，可以通过-XX:PreBlockSpin自行修改。</p>
<p>​        所谓的适应性自旋就是在原来自旋的基础之上，自旋时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态的决定的，简单理解就是同一个锁对象，上一个线程自旋等待马上获得了锁，那么下一个线程就会认为它也有可能获得锁，进而允许自己自旋等待时间相对更长一些，比如持续100次循环。另一方面，如果自旋很少能够获取到锁，那么此后的线程可能直接跳过自旋等待，以免浪费处理器资源，适应性自旋是Java虚拟机对性能监控信息的不断完善，对程序锁的状况预测越来越准确。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​        锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判断依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。    </p>
<p>​        可能会为此感到疑惑，变量是否逃逸，对虚拟机来讲需要使用复杂的过程分析才能确定，但是对于我们程序员自己应该是很清楚，怎么会明知道不可能存在数据争用的情况下还需要同步呢？答案是有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中出现的频繁程度也许超过了大部分程序员的想象，如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK5之前，字符串加法会转化为StringBuffer对象的连续append()操作，在JDK5以后的版本中，会转为StringBuilder对象的连续append()操作，所以上述代码会变成如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在你肯定不会认为这段代码没有涉及同步了吧，每个StringBuffer.append()方法中都有一个同步块，锁都是sb对象。。虚拟机观察变量sb,经过逃逸分析后发现它的动态作用域被限制在concatString()方法内部，也就是sb的所有引用都永远不会逃逸到concatString()方法之外。在解释执行这里仍然会加锁，到那时经过服务端编译器即时编译之后，这段代码的就会忽略所有的同步措施而直接执行。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​        编写同步代码时，我们总是推荐将同步块的作用范围限制得尽量下——只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在竞争，等待锁的线程也能更快的拿到锁。</p>
<p>​        大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>​        上面的代码就属于这类情况，如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把锁同步的范围扩展(粗化)到这个操作序列的外部。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>​        JDK6加入的新型锁机制，它的名字中的“轻量级”是相对于操作系统互斥量来实现的传统锁而言，因此传统的锁机制就被成为“重量级”锁。需要明确的是，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能损耗。</p>
<p>​        要理解轻量级锁以及其后的偏向锁的原理和运作过程，必须对HotSpot虚拟机对象的内存布局(尤其是对象头)有所了解，HotSpot虚拟机的对象头(Object Header)分两部分，第一部分用于存储对象自身运行时数据，如哈希码(HashCode)、GC分代年龄等，这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方成为“Mark Word”。这部分时实现轻量级锁和偏向锁的关键。另外一部分是用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p>
<p>​        由于对象头信息是与对象自身定义的数据无关的额外的存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存存储尽量多的信息。例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特固定为0(表示未进入偏向模式)。对象除了未被锁定的正常状态外，还有轻量级锁定，重量级锁定、GC标志、可偏向等多种状态，这些状态下的对象头存储内容如下表</p>
<img src="https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:67%;">

<p>​        轻量级锁的工作过程：<strong>在代码即将进入同步块的时候，如果此对象没有被锁定(锁标志为“01”状态)，虚拟机首先将在当前线程的栈帧种建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝，然后，虚拟机将使用CAS操作尝试把对象的Mark word更新为指向Lock Record的指针，如果成功了，就代表当前线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为“00”，表示此对象处于轻量级锁定状态</strong>。</p>
<p>​        如果CAS更新操作失败，那意味着至少存在一条线程与当前线程获取竞争该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经持有这个对象的锁，那么直接进入同步块继续执行就可以了，否则说明这个对象锁已经被其他线程抢占了。如果出现两条以上的线程抢占锁，那轻量级锁就不再生效了，立即膨胀为重量级锁，锁的标志为变为“10”，此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程必须进入阻塞状态。</p>
<p>​        轻量级锁提升程序同步性能的依据是“对于绝大部分的锁，整个同步周期内都是不存在竞争的”这一经验法则，如果存在竞争，处理互斥量的本身开销外，还额外发生了CAS开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>​        偏向锁也是JDK6中引入的一项锁优化措施，它的目的是消除数据的在无竞争情况下的同步原语，进一步提高程序性能。你可以理解为轻量级锁是在无竞争的情况下使用了CAS操作去消除同步使用的互斥量，而偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不去做了。</p>
<p>​        偏向锁，顾名思义，就是偏向某个线程的锁。那到底偏向的是哪个锁呢？什么条件下才能满足偏向锁条件呢？它偏向的是第一个获得它的线程，这点应该很好理解，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。假设当前虚拟机启用了偏向锁(启用参数-XX:+UseBiasedLocking，默认启动)，那么当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为“01”，把偏向模式设置为“1”，表示进入偏向锁模式。同时使用CAS操作把获取到这个锁的线程ID记录再对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(注意：前提是没有竞争)。</p>
<p>​        一旦出现另外一个线程去获取这个锁的情况，偏向模式马上宣布结束。根据锁对象目前是否处于被锁定状态决定是否撤销偏向(偏向模式设置为“0”)，<strong>撤销后标志位恢复到未锁定(标志位为“01”)或轻量级锁(标志位为“00”)</strong>，之所以出现两种状态取决于是否执行重偏向，如果支持恢复为可偏向但未偏向(未锁定)，如果不支持，恢复为轻量级锁，后续的同步操作按照轻量级锁模型进行。</p>
<p>​        值得一提的是，偏向锁的ID需要记录在Mark Word(占用23个比特)，你可能为此感到疑惑：那对象的哈希码值怎么办？在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变(强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码)，否则很多依赖对象哈希码的API都可能存在出错风险。而大多数对象的哈希码来源是Object::hashCode()方法，返回的是对象的一致性哈希码，这个值能强制保证不变的，它通过在对象头存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态里面被撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态(标志位为“01”)下的Mark Word，其中自然可以存储原来的哈希码。</p>
<p>​        偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果在多线程环境下， 那偏向模式就是多余的。关于偏向锁的启用及参数可以通过查看JVM参数配置，JVM启动之后并不会里面开启偏向锁，默认4秒之后开启，之所以这样做是因为JVM运行时是多线程模式，如果启动就开启偏向锁，不但多余对启动性能也有所影响，。</p>
<h4 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h4><p><img src="https://img-blog.csdn.net/20180908110545722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM4MDgzNjE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8Esynchronized%E9%94%81%E4%BC%98%E5%8C%96/" data-id="ckb0b8jss0000wor608ap7f8w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-你到底了不了解volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/%E4%BD%A0%E5%88%B0%E5%BA%95%E4%BA%86%E4%B8%8D%E4%BA%86%E8%A7%A3volatile/" class="article-date">
  <time datetime="2020-06-04T04:50:14.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/%E4%BD%A0%E5%88%B0%E5%BA%95%E4%BA%86%E4%B8%8D%E4%BA%86%E8%A7%A3volatile/">你到底了不了解volatile?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>​        JVM关键字 ,语义：保证有序性和可见性。在理解volatile之前先了解Java内存模型。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>​        Java虚拟机规范试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异。通过定义主内存和本地内存来制定程序中各个变量的访问规则，也就是虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。此处的变量包括了实例字段、静态字段、和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的。Java内存模型没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即时编译器进行调整嗲吗执行顺序这类优化措施(与volatile直接相关，下文祥讲)。</p>
<p>​        Java内存模型规定了所有的变量都存储在主存中，每条线程有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主存副本拷贝，线程对变量所有的操作必须在本地内存中进行，不同的线程无法直接访问对方工作内存中的变量，必须经过主内存(该模型与Java内存区域的堆、栈、方法区等不是同一个层次的内存划分，基本上没啥关系)，需要注意的是volatile变量的访问同样需要拷贝到本地内存中，但是由于它特殊的操作顺序性规定使它看上去就像是在主内存读写访问一样。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>​        Java内存模型定义了8种操作来完成主内存和本地内存间的交互细节，虚拟机实现时必须保证这8种操作是原子性的，不可再分的(long、double类型变量除外)。</p>
<ul>
<li><p>lock(锁定)：作用于主内存的变量，把一个变量标识为一个线程独占</p>
</li>
<li><p>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放，释放之后才能被其他线程锁定</p>
</li>
<li><p>read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load(载入)：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中</p>
</li>
<li><p>use(使用)：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量值的字节码指令时将会执行这个操作</p>
</li>
<li><p>assign(赋值)：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</p>
</li>
<li><p>store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传给主内存中，一边随后的write操作使用</p>
</li>
<li><p>write(写入)：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存中的变量中</p>
<p>​    </p>
<p>​    如果把一个变量从主内存复制到工作内存中，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，那就要顺序执行store和write操作，Java内存只要求这两个操作必须按顺序执行，而没有保证是连续执行，也就是说read与load之间，store与write之间是可插入其他指令的，这也是乱序执行出现的先天条件，另外Java内存模型还定义了以上操作必须遵循的规则，加上volatile的一些特殊规定就已经完全确定了Java内存中哪些内存访问操作是在并发下是安全的。</p>
</li>
</ul>
<h3 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h3><p>​        关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量被定义为volatile类型之后，它具备两种特性，第一种是保证此变量对所有线程的可见性，也就是说，当一个线程修改了这个变量的值，新值对于其他线程是立即可见的，这是普通变量不能做到的，对于普通变量的值被修改之后，需要将本地内存的值回写主内存，其他才能读取到最新值。使用volatile第二个语义是禁止指令重排序优化，普通变量只能保证该方法执行过程种所有的依赖结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中顺序一致。因为在一个线程执行过程中无法感知到这点，这也是Java内存模型中描述的所谓”线程内表现为串行的语义(Within-Thread As-If-Serial Semantics)”，需要注意的指令重排序优化是机器级的优化操作，提前执行的代码是指这代码对应的汇编代码被提前执行。</p>
<h3 id="为什么需要保证有序性？"><a href="#为什么需要保证有序性？" class="headerlink" title="为什么需要保证有序性？"></a>为什么需要保证有序性？</h3><p>​        这个问题在单核环境下是不需要考虑的。既然volatie能够保证指令有序那么一定是出现了乱序执行，为什么会乱序执行？首先需要了解CPU相关原理和优化。</p>
<h3 id="CPU指令乱序优化"><a href="#CPU指令乱序优化" class="headerlink" title="CPU指令乱序优化"></a>CPU指令乱序优化</h3><p>​        如你所见,这里的乱序实际上是一种优化。CPU将主存的指令通过总线读取到寄存器，然后由ALU(逻辑运算单元)进行运算，整个过程几乎所有的时间都用在将主存的指令加载进寄存器，与ALU处理有几个数量级的差距(大概100倍)。想象一下，主存将两条指令加载到寄存器中，第一条指令需要再次执行I/O操作读取主存某一位置的数据，第二条指令是数据运算，那么在指令乱序执行出现之前，CPU只能老老实实等到I/O操作完成之后再进行运算，等待的这段时间足够100次运算，这对于CPU来讲是不可接受的，为了提高CPU利用率，CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要正确处理指令依赖情况以保障程序能得到正确的执行结果。举个例子，指令1读取主存中a的大小，指令2对读取到的a加1，指令3将地址b的值加10，CPU分析出指令3对于1、2没有依赖，那么执行顺序可能调整为3、1、2。这样看来乱序执行不但没有影响最终结果反而提高了CPU利用率。但是在多核环境中，CPU乱序优化可能弄巧成拙带来不符合预期的结果。典型的就是DCL单例模型，因为Java对象的创建并不是原子操作，乱序执行可能会将内存地址指向对象引用在初始化完成之前执行，线程虽然已经拿到不为null的对象，但是对象并未完成初始化，酿成大错。这就是机器级的优化操作。</p>
<h3 id="为何说volatile禁止指令重排序？"><a href="#为何说volatile禁止指令重排序？" class="headerlink" title="为何说volatile禁止指令重排序？"></a>为何说volatile禁止指令重排序？</h3><p>​        再举个例子，在多核环境下，指令1把地址A的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10x2和Ax2+10显然是不相同的，但是指令3是可以排在任意位置。volatile此时能够保证指令1和指令2按顺序执行，得到正确的结果。</p>
<h4 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo singleInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleInstance = <span class="keyword">new</span> Demo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer a;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile底层内存屏障的实现"><a href="#volatile底层内存屏障的实现" class="headerlink" title="volatile底层内存屏障的实现"></a>volatile底层内存屏障的实现</h3><p>​        将上述DCL单例代码编译后发现，volatile修饰的变量在赋值后多执行一个“ <em>lock add1 $0x0,(%esp)</em>”操作，这个操作相当于一个内存屏障(指重排序时不能把后面的指令重排序到内存屏障之前的位置)，只有一个CPU访问内存时，并不需要内存屏障：但如果有两个或者更多CPU访问同一块内存，且其中一个在观测另外一个，就需要内存屏障来保证一致性。<em>lock add1 $0x0,(%esp)esp</em>，没有采用nop空操作指令是因为lock前缀不允许配合nop指令，关于lock前缀，它的作用是使得本CPU得Cache写入主存，该动作也会引起别的CPU或者别的内核的Cache无效化(invalidate,这里涉及到内存一致性协议MESI),这种操作相当于对Cache中的变量做了一次前面Java内存模型中的<strong>store</strong>和<strong>write</strong>操作。</p>
<h3 id="volatile并不安全"><a href="#volatile并不安全" class="headerlink" title="volatile并不安全"></a>volatile并不安全</h3><p>​        volatile只能保证语句可见性和有序性，并不保证原子性，如DCL单例，如果需要保证单例正确创建仍然需要synchronized关键字或JUC中的锁保证同步。</p>
<h3 id="volatile的性能"><a href="#volatile的性能" class="headerlink" title="volatile的性能"></a>volatile的性能</h3><p>​        与众多的保障并发安全的工具相比，volatile的性能如何？某些情况下volatile的同步机制性能确实要优于锁(synchronized关键字或JUC包里面的锁)，但由于虚拟机对锁实行了许多消除和优化，使得很难量化的认为volatile就会比synchronized快多少。与普通变量相比，volatile的读操作性能消耗和普通变量几乎没有查别，写操作稍慢，因为需要插入内存屏障指令保证处理器不发生乱序执行。即便如此，多数场景下volatile的总开销仍然比锁低，我们在使用volatile和锁中做选择唯一依据仅仅是volatile语义能够满足使用场景。</p>
<h3 id="Java内存模型对volatile变量定义的特殊规则"><a href="#Java内存模型对volatile变量定义的特殊规则" class="headerlink" title="Java内存模型对volatile变量定义的特殊规则"></a>Java内存模型对volatile变量定义的特殊规则</h3><p>​        假设T表示一个线程,V和W表示volatile变量。在进行read,load,use,assign,store和write操作使需要的规则：</p>
<ul>
<li><input disabled="" type="checkbox"> 只有T对V执行一个load动作时，T才能对V执行use动作，并且只有T对V的后一个动作时use，才能执行load。use动作可以看作与load,read相关联，必须连在一起出现(这条规则要求在工作内存中每次使用V前都必须先从主内存刷新最新值)</li>
<li><input disabled="" type="checkbox"> 只有T对V执行的前一个动作时assign的时候，T才能对V执行store,并且只有T对V执行的后一个动作时store的时候,T才能对V执行assign，T对V的assign动作可以看作与store,write动作相关联，必须连在一起出现(这条规则要求在工作内存中每次修改都必须立刻同步回主内存中)</li>
<li><input disabled="" type="checkbox"> 假定动作A是T对V实施的use或assign动作，假定F是和动作A相关联的load或store动作，假定动作P是动作F相应的对变量V的read或write动作，类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作，如果A先于B，那么先于Q(这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同)</li>
</ul>
<h3 id="Java提供了几种可见性实现？"><a href="#Java提供了几种可见性实现？" class="headerlink" title="Java提供了几种可见性实现？"></a>Java提供了几种可见性实现？</h3><p>​        除了volatile，Java还提供了synchronized和final两个关键字实现可见性。同步块的可见性是由“对一个变量执行unlock操作之前必须将此变量同步回主内存中(执行store,write)”。而final关键字的可见性是指，被final修饰的字段在构造器中一旦初始化完成，并且构造器中没有把“this”的引用传递出去(this引用逃逸是一件危险的事情，其他线程可能通过这个引用访问到“初始化一半的对象”)，那在其他线程中就能看见final字段的值。关于final的可见性保证不是很容易理解，通过下面的例子可能对于理解有更多的帮助。</p>
<p>​        final修饰的变量只能显示的赋值一次，但是不代表不可以多次初始化，例如：final int a;a在构造函数之前已经被初始化值为0，为了保证final修饰的值不会在初始化之前被访问到，我们需要保证在构造函数中，正在被构造的对象引用”this”没有逸出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里在构造函数中将this引用逸出了，假如这里发生重排序，a=1在Object=this之后执行，那么其他线程可能访问到a=0</span></span><br><span class="line">        object = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="happens-before-先行发生"><a href="#happens-before-先行发生" class="headerlink" title="happens-before(先行发生)"></a>happens-before(先行发生)</h3><p>如果Java内存模型中所有的有序性仅仅依靠volatile和synchronized完成，那么有一些操作会变得很复杂,Java语言中有一个“先行发生（happens-before)的原则，这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。</p>
<p>​        先行发生是Java内存模型中定义两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就说发生操作B之前，操作A产生的影响能够被操作B观察到。Java内存模型存在一些”天然的”先行发生关系，这些先行发生关系不需要任何同步器协调就已经存在，可以在编译中直接使用，如果两个操作之间的关系不在此列，并且从这些规则中无法推导出来，那他们就没有任何顺序性保障。</p>
<ul>
<li><input disabled="" type="checkbox"> 程序次序规则：在一个线程内，按照代码顺序，书写在前面的操作先行发生于后面的操作，准确来说，应是控制流顺序而不是程序代码顺序，因为要开发分支，循环等结构。</li>
<li><input disabled="" type="checkbox"> 管程锁定规则：一个unlock操作先行发生与后面对通过一个锁的lock操作</li>
<li><input disabled="" type="checkbox"> volatile变量规则：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作，”后面”是指时间上的先后顺序</li>
<li><input disabled="" type="checkbox"> 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li><input disabled="" type="checkbox"> 线程终止规则：线程中所有的操作必须先行发生于对此线程的终止检测，可以通过Thread.join()、Thread.isAlive()返回值等手段检测到线程已经终止执行。</li>
<li><input disabled="" type="checkbox"> 线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。</li>
<li><input disabled="" type="checkbox"> 对象终结规则：对一个对象的初始化完成(构造函数执行完成)先行发生于它的finalize()方法开始</li>
<li><input disabled="" type="checkbox"> 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/%E4%BD%A0%E5%88%B0%E5%BA%95%E4%BA%86%E4%B8%8D%E4%BA%86%E8%A7%A3volatile/" data-id="ckb0ayywc00007or6bv7g9g2t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/04/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%90%97/">这里有你常用的分布式锁吗</a>
          </li>
        
          <li>
            <a href="/2020/06/04/%E6%88%91%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BA%86/">我再也不怕面试被问零拷贝了</a>
          </li>
        
          <li>
            <a href="/2020/06/04/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%9F%E5%B0%B1%E8%BF%99%E4%B9%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84/">Redis持久化也就这么多需要掌握的</a>
          </li>
        
          <li>
            <a href="/2020/06/04/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E7%9C%8BAQS%E6%BA%90%E7%A0%81/">一行一行看AQS源码</a>
          </li>
        
          <li>
            <a href="/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%8Esynchronized%E9%94%81%E4%BC%98%E5%8C%96/">Java线程实现与synchronized锁优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>